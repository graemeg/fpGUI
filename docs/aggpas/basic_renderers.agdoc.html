<html><head><title>Anti-Grain Geometry - Basic Renderers</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="stylesheet" type="text/css" 
href="basic_renderers.agdoc_files/agg.css">
</head><body><a name="PAGE_BASIC_RENDERERS"><b></b></a>


<table style="margin: 0px;" height="1px" width="640px" border="0" 
cellpadding="0" cellspacing="0">
<tbody><tr>
<td bgcolor="#583927"></td>
</tr>
</tbody></table>
<table style="margin: 0px;" width="640px" border="0" cellpadding="0" 
cellspacing="0">
<tbody><tr>
<td>
<table style="margin: 0px;" width="170px" border="0" cellpadding="0" 
cellspacing="0">
<tbody><tr><td><a href="http://www.antigrain.com/index.html" 
class="mpmenu">Home/</a></td></tr>
<tr><td><a href="http://www.antigrain.com/doc/index.html" class="mpmenu">Table
 of Content/</a></td></tr>
<tr><td><a href="" class="mpmenu"></a></td></tr>
<tr><td><a href="" class="mpmenu"></a></td></tr>
<tr><td><a href="" class="mpmenu"></a></td></tr>
<tr><td><a href="" class="mpmenu"></a></td></tr>
</tbody></table>
</td>
<td width="1px" bgcolor="#583927"></td>
<td style="text-align: right;" valign="top" width="450px">
<table style="margin: 0px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr>
<td><img src="basic_renderers.agdoc_files/agg_logo.gif" border="0"></td>
</tr>
<tr>
<td>
<table style="margin: 0px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr height="15px">
<td>&nbsp;&nbsp;<a class="topmenu" 
href="http://www.antigrain.com/news/index.html">News</a>&nbsp;&nbsp;</td>
<td width="1px" bgcolor="#8e521d"></td>
<td>&nbsp;&nbsp;<a class="topmenu" 
href="http://www.antigrain.com/doc/index.html">Docs</a>&nbsp;&nbsp;</td>
<td width="1px" bgcolor="#8e521d"></td>
<td>&nbsp;&nbsp;<a class="topmenu" 
href="http://www.antigrain.com/download/index.html">Download</a>&nbsp;&nbsp;</td>
<td width="1px" bgcolor="#8e521d"></td>
<td>&nbsp;&nbsp;<a class="topmenu" 
href="http://www.antigrain.com/maillist/index.html">Mailing List</a>&nbsp;&nbsp;</td>
<td width="1px" bgcolor="#8e521d"></td>
<td>&nbsp;&nbsp;<a class="topmenu" 
href="http://www.antigrain.com/cvs/index.html">CVS</a>&nbsp;&nbsp;</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody></table>
</td>
</tr>
</tbody></table>
<table style="margin: 0px;" height="1px" width="640px" bgcolor="#583927"
 border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td></tr></tbody></table>


<table width="640px"><tbody><tr><td style="text-align: justify;"><p>
</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><h1>Basic Renderers<span 
class="subtitle"><br>Getting Started with Simple Console Applications</span></h1></td></tr></tbody></table>


<table class="toc" width="640px"><tbody><tr><td>
    <div style="margin-left: 2em; padding: 3px; font-size: 14px;"><a 
href="#toc0001"><b>Rendering Buffer</b></a>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0002">The First and the Simplest Example</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0003">Class rendering_buffer</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0004">Two Modifications of the Example</a></div></div>
    <div style="margin-left: 2em; padding: 3px; font-size: 14px;"><a 
href="#toc0005"><b>Pixel Format Renderers</b></a>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0006">Creation</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0007">Member Functions</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0008">Alpha-Mask Adaptor</a></div></div>
    <div style="margin-left: 2em; padding: 3px; font-size: 14px;"><a 
href="#toc0009"><b>Basic Renderers</b></a>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0010">Creation</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0011">Member Functions</a></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0012">A common example</a></div></div>
    <div style="margin-left: 2em; padding: 3px; font-size: 14px;"><a 
href="#toc0013"><b>Primitives and Markers Renderers</b></a>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0014">Primitives Renderer</a>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0015">Declaration</a></div>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0016">Creation</a></div>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0017">Member functions</a></div></div>
        <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0018">Marker Renderer</a>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0019">Declaration</a></div>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0020">Creation</a></div>
            <div style="margin-left: 2em; font-size: 12px;"><a 
href="#toc0021">Member Functions</a></div></div></div>

</td></tr></tbody></table>

<h2>Rendering Buffer<a name="toc0001"></a></h2>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Here
 we start with creating a frame buffer in memory and writing it to a 
file of
the simplest possible raster format. It's <a 
href="http://netpbm.sourceforge.net/doc/ppm.html"><img 
src="basic_renderers.agdoc_files/link.gif" border="0">PPM (Portable 
Pixel Map)</a>. Although, it isn't natively supported by <a 
href="http://www.microsoft.com/"><img 
src="basic_renderers.agdoc_files/link.gif" border="0"><b>Microsoft</b></a>
 Windows, 
there are many viewers and converters that can work with it, 
for example, <a href="http://www.irfanview.com/"><img 
src="basic_renderers.agdoc_files/link.gif" border="0">IrfanView 
(www.irfanview.com)</a>.
All <b>AGG</b> console examples use the P6 256 format, that is RGB, one 
byte per channel.
We assume that we work with an RGB-buffer in memory organized as 
follows:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/pixfmt_rgb24.gif" title="" border="0"><br><i></i></center></td></tr></tbody></table>

<h3>The First and the Simplest Example<a name="toc0002"></a></h3>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>There
 is the first example, it's in <code>agg2/tutorial/t01_rendering_buffer.cpp</code></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw2">#include</span> <span class="op">&lt;</span>stdio<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="op">&lt;</span>string<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="str">"<a href="http://www.antigrain.com/__code/include/agg_rendering_buffer.h.html">agg_rendering_buffer.h</a>"</span>

<span class="kw1">enum</span>
<span class="op">{</span>
    frame_width <span class="op">=</span> <span class="num">320</span><span class="op">,</span>
    frame_height <span class="op">=</span> <span class="num">200</span>
<span class="op">}</span><span class="op">;</span>

<span class="rem">// Writing the buffer to a .PPM file, assuming it has </span>
<span class="rem">// RGB-structure, one byte per color component</span>
<span class="rem">//--------------------------------------------------</span>
<span class="kw1">bool</span> write_ppm<span class="op">(</span><span class="kw1">const</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buf<span class="op">,</span> 
               <span class="kw1">unsigned</span> width<span class="op">,</span> 
               <span class="kw1">unsigned</span> height<span class="op">,</span> 
               <span class="kw1">const</span> <span class="kw1">char</span><span class="op">*</span> file_name<span class="op">)</span>
<span class="op">{</span>
    FILE<span class="op">*</span> fd <span class="op">=</span> fopen<span class="op">(</span>file_name<span class="op">,</span> <span class="str">"wb"</span><span class="op">)</span><span class="op">;</span>
    <span class="kw1">if</span><span class="op">(</span>fd<span class="op">)</span>
    <span class="op">{</span>
        fprintf<span class="op">(</span>fd<span class="op">,</span> <span class="str">"P6 %d %d 255 "</span><span class="op">,</span> width<span class="op">,</span> height<span class="op">)</span><span class="op">;</span>
        fwrite<span class="op">(</span>buf<span class="op">,</span> <span class="num">1</span><span class="op">,</span> width <span class="op">*</span> height <span class="op">*</span> <span class="num">3</span><span class="op">,</span> fd<span class="op">)</span><span class="op">;</span>
        fclose<span class="op">(</span>fd<span class="op">)</span><span class="op">;</span>
        <span class="kw1">return</span> <span class="kw1">true</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="kw1">return</span> <span class="kw1">false</span><span class="op">;</span>
<span class="op">}</span>

<span class="rem">// Draw a black frame around the rendering buffer, assuming it has </span>
<span class="rem">// RGB-structure, one byte per color component</span>
<span class="rem">//--------------------------------------------------</span>
<span class="kw1">void</span> draw_black_frame<span class="op">(</span>agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">&amp;</span> rbuf<span class="op">)</span>
<span class="op">{</span>
    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> rbuf<span class="op">.</span>height<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> p <span class="op">=</span> rbuf<span class="op">.</span>row_ptr<span class="op">(</span>i<span class="op">)</span><span class="op">;</span>
        <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span> <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span> <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
        p <span class="op">+=</span> <span class="op">(</span>rbuf<span class="op">.</span>width<span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="num">2</span><span class="op">)</span> <span class="op">*</span> <span class="num">3</span><span class="op">;</span>
        <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span> <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span> <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> <span class="num">0</span><span class="op">;</span>
    <span class="op">}</span>
    memset<span class="op">(</span>rbuf<span class="op">.</span>row_ptr<span class="op">(</span><span class="num">0</span><span class="op">)</span><span class="op">,</span> <span class="num">0</span><span class="op">,</span> rbuf<span class="op">.</span>width<span class="op">(</span><span class="op">)</span> <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
    memset<span class="op">(</span>rbuf<span class="op">.</span>row_ptr<span class="op">(</span>rbuf<span class="op">.</span>height<span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="num">1</span><span class="op">)</span><span class="op">,</span> <span class="num">0</span><span class="op">,</span> rbuf<span class="op">.</span>width<span class="op">(</span><span class="op">)</span> <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
<span class="op">}</span>


<span class="kw1">int</span> <span class="kw1">main</span><span class="op">(</span><span class="op">)</span>
<span class="op">{</span>
    <span class="rem">// In the first example we do the following:</span>
    <span class="rem">//--------------------</span>
    <span class="rem">// Allocate the buffer.</span>
    <span class="rem">// Clear the buffer, for now "manually"</span>
    <span class="rem">// Create the rendering buffer object</span>
    <span class="rem">// Do something simple, draw a diagonal line</span>
    <span class="rem">// Write the buffer to agg_test.ppm</span>
    <span class="rem">// Free memory</span>

    <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">[</span>frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">]</span><span class="op">;</span>

    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> rbuf<span class="op">.</span>height<span class="op">(</span><span class="op">)</span><span class="op">/</span><span class="num">2</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        <span class="rem">// Get the pointer to the beginning of the i-th row (Y-coordinate)</span>
        <span class="rem">// and shift it to the i-th position, that is, X-coordinate.</span>
        <span class="rem">//---------------</span>
        <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> ptr <span class="op">=</span> rbuf<span class="op">.</span>row_ptr<span class="op">(</span>i<span class="op">)</span> <span class="op">+</span> i <span class="op">*</span> <span class="num">3</span><span class="op">;</span>
        
        <span class="rem">// PutPixel, very sophisticated, huh? :)</span>
        <span class="rem">//-------------</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">127</span><span class="op">;</span> <span class="rem">// R</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">200</span><span class="op">;</span> <span class="rem">// G</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">98</span><span class="op">;</span>  <span class="rem">// B</span>
    <span class="op">}</span>

    draw_black_frame<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>
    write_ppm<span class="op">(</span>buffer<span class="op">,</span> frame_width<span class="op">,</span> frame_height<span class="op">,</span> <span class="str">"agg_test.ppm"</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> buffer<span class="op">;</span>
    <span class="kw1">return</span> <span class="num">0</span><span class="op">;</span>
<span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>In 
this example you don't even have to link it with any <b>AGG</b> files, 
you need only to 
indicate the <b>AGG</b> <code>include</code> directory in the command 
line of your compiler.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>When
 you compile and run it you should see the following result.
</p></td></tr></tbody></table><table width="640px"><tbody><tr><td><center><img
 src="basic_renderers.agdoc_files/rendering_buffer1.gif" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Almost
 everything here is coded &#8220;manually&#8221;. The only class we use is 
<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>.
 This class doesn't know anything about 
the pixel format in memory, it just keeps an array of pointers 
to each row. It is your responsibility to allocate and deallocate
actual memory for the buffer. You can use any available mechanism 
for that, a system API function, simple memory allocation, or even 
an array defined statically. In the above example we allocate 
<nobr><code>width * height * 3</code></nobr> bytes of memory, since we 
use 3 bytes per pixel.
The rows are not aligned in memory, but they can be for better 
performance or
if it is required by used API.</p></td></tr></tbody></table>

<h3>Class rendering_buffer<a name="toc0003"></a></h3>

<a name="rendering_buffer"><b></b></a>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Include
 file: <a 
href="http://www.antigrain.com/__code/include/agg_rendering_buffer.h.html">agg_rendering_buffer.h</a></p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
rendering buffer class keeps pointers to each rows, and basically it's 
all it does. It doesn't look like a great achievement, but try to keep 
reading.
The interface and functionality of it is very simple. 
It's a <code>typedef</code> of class template <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a>:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">typedef</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a><span class="op">&lt;</span><a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">&gt;</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<a name="row_ptr_cache"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
interface and the functionality of class <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a>
 is:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> T<span class="op">&gt;</span> <span class="kw1">class</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a>
<span class="op">{</span>
<span class="kw1">public</span>:
    <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a><span class="op">(</span><span class="op">)</span><span class="op">;</span>

    <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a><span class="op">(</span>T<span class="op">*</span> buf<span class="op">,</span> <span class="kw1">unsigned</span> width<span class="op">,</span> <span class="kw1">unsigned</span> height<span class="op">,</span> <span class="kw1">int</span> stride<span class="op">)</span><span class="op">;</span>

    <span class="kw1">void</span> attach<span class="op">(</span>T<span class="op">*</span> buf<span class="op">,</span> <span class="kw1">unsigned</span> width<span class="op">,</span> <span class="kw1">unsigned</span> height<span class="op">,</span> <span class="kw1">int</span> stride<span class="op">)</span><span class="op">;</span>

          T<span class="op">*</span> buf<span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="kw1">const</span> T<span class="op">*</span> buf<span class="op">(</span><span class="op">)</span>    <span class="kw1">const</span><span class="op">;</span>
    <span class="kw1">unsigned</span> width<span class="op">(</span><span class="op">)</span>  <span class="kw1">const</span><span class="op">;</span>
    <span class="kw1">unsigned</span> height<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
    <span class="kw1">int</span>      stride<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
    <span class="kw1">unsigned</span> stride_abs<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>

          T<span class="op">*</span> row_ptr<span class="op">(</span><span class="kw1">int</span><span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span><span class="op">)</span> 
          T<span class="op">*</span> row_ptr<span class="op">(</span><span class="kw1">int</span> y<span class="op">)</span><span class="op">;</span>
    <span class="kw1">const</span> T<span class="op">*</span> row_ptr<span class="op">(</span><span class="kw1">int</span> y<span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
    row_data row    <span class="op">(</span><span class="kw1">int</span> y<span class="op">)</span> <span class="kw1">const</span><span class="op">;</span> 
    T <span class="kw1">const</span><span class="op">*</span> <span class="kw1">const</span><span class="op">*</span> rows<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>

    <span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> RenBuf<span class="op">&gt;</span> <span class="kw1">void</span> copy_from<span class="op">(</span><span class="kw1">const</span> RenBuf<span class="op">&amp;</span> src<span class="op">)</span><span class="op">;</span>

    <span class="kw1">void</span> clear<span class="op">(</span>T value<span class="op">)</span>
<span class="op">}</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
source code: <a 
href="http://www.antigrain.com/__code/include/agg_rendering_buffer.h.html#row_ptr_cache">row_ptr_cache</a>
</p></td></tr></tbody></table><table style="margin: 0px;" height="1px" 
width="640px" bgcolor="#583927" border="0" cellpadding="0" 
cellspacing="0"><tbody><tr><td></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
class doesn't have any assertion or verification code, so that, your 
responsibility is to properly attach an actual memory buffer to the 
object 
before using it. It can be done in the constructor as well as with the 
<code>attach()</code> function. The arguments of them are:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p></p><ul
 type="disc">
<li><b>buf</b> &#8212; A pointer to the memory buffer.</li>
<li><b>width</b> &#8212; Width of the image in <b>pixels</b>. The rendering 
buffer
   doesn't know anything about pixel format and about the size
   of one pixel in memory. This value is simply stored in its data 
   member <code>m_width</code> and returned by <code>width()</code> 
function.</li>
<li><b>height</b> &#8212; The height of the buffer in <b>pixels</b> (the 
number of rows).</li>
<li><b>stride</b> &#8212; The &#8220;stride&#8221; (big step) of the rows measured in 
objects of type <code>T</code>.
   Class <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>
 is &#8220;<code>typedefed</code>&#8221; as <code><a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#row_ptr_cache">row_ptr_cache</a>&lt;<a
 href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a>&gt;</code>,
 so,
   this value is in bytes. <b>Stride</b> determines the physical width 
of
   one row in memory. If this value is negative the direction of 
   the <b>Y</b> axis is inverted, that is, <code>Y==0</code> will point 
to the last
   row of the buffer, <code>Y==height-1</code> &#8212; to the first one. The 
absolute value 
   of <b>stride</b> is important too, because it allows you to work with
 buffers 
   whose rows are aligned in memory (like in Windows BMP, for example). 
   Besides, this  parameter allows you to work with any rectangular area
 
   inside the buffer as with the whole buffer.</li></ul><p></p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Function
 <code>attach()</code> changes the buffer or its parameters. It takes 
care of
reallocating the memory for the row-pointers buffer, so that, you can 
call it
anytime. It will reallocate the memory if (and only if) new <code>height</code>
 is
is larger than any previously attached.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
cost of creation is just initializing of the variables (set to 0), 
the cost of <code>attach()</code> is allocating of <code>sizeof(ptr) * 
height</code> bytes
of memory and initializing of the pointers to the rows.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
most frequently used function is <code>row_ptr(y)</code> that simply 
returns a pointer
to the beginning of the <nobr><code>y</code><sup>th</sup></nobr> row, 
considering the direction of 
the <nobr><b>Y</b>-axis</nobr>.</p></td></tr></tbody></table> 

<table class="warning" width="640px"><tbody><tr><td><b>IMPORTANT!</b><br>
The rendering buffer does not perform any clipping or bound checking, 
it's the responsibility of higher level classes.
</td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
accessors, 
<code>buf()</code>, <code>width()</code>, <code>height()</code>, <code>stride()</code>,
 <code>stride_abs()</code> 
should be obvious.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Function
 <code>copy_from()</code> copies the content of another buffer to &#8220;this&#8221;
one. The function is safe, if the <b>width</b> or <b>height</b> is 
different
it will copy the maximal possible area. Basically, it's used to copy 
rendering buffers of equal size.</p></td></tr></tbody></table>

<h3>Two Modifications of the Example<a name="toc0004"></a></h3>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>First,
 negate the <b>stride</b> when creating the rendering buffer object:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre>    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               <span class="op">-</span>frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
result is:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/rendering_buffer2.gif" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>
<table style="margin: 0px;" height="1px" width="640px" bgcolor="#583927"
 border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Second,
 let's try to attach to some part of the allocated buffer. This 
modification
actually attaches to the same buffer twice, first, to the whole frame, 
then to 
its part, with 20 pixel margin.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">int</span> <span class="kw1">main</span><span class="op">(</span><span class="op">)</span>
<span class="op">{</span>
    <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">[</span>frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">]</span><span class="op">;</span>

    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    <span class="rem">// Draw the outer black frame</span>
    <span class="rem">//------------------------</span>
    draw_black_frame<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>

    <span class="rem">// Attach to the part of the buffer, </span>
    <span class="rem">// with 20 pixel margins at each side.</span>
    rbuf<span class="op">.</span>attach<span class="op">(</span>buffer <span class="op">+</span> 
                  frame_width <span class="op">*</span> <span class="num">3</span> <span class="op">*</span> <span class="num">20</span> <span class="op">+</span>      <span class="rem">// initial Y-offset</span>
                  <span class="num">3</span> <span class="op">*</span> <span class="num">20</span><span class="op">,</span>                     <span class="rem">// initial X-offset</span>
                frame_width <span class="op">-</span> <span class="num">40</span><span class="op">,</span>
                frame_height <span class="op">-</span> <span class="num">40</span><span class="op">,</span>
                frame_width <span class="op">*</span> <span class="num">3</span>               <span class="rem">// Note that the stride</span>
                                              <span class="rem">// remains the same</span>
                <span class="op">)</span><span class="op">;</span>               

    <span class="rem">// Draw a diagonal line</span>
    <span class="rem">//------------------------</span>
    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> rbuf<span class="op">.</span>height<span class="op">(</span><span class="op">)</span><span class="op">/</span><span class="num">2</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        <span class="rem">// Get the pointer to the beginning of the i-th row (Y-coordinate)</span>
        <span class="rem">// and shift it to the i-th position, that is, X-coordinate.</span>
        <span class="rem">//---------------</span>
        <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> ptr <span class="op">=</span> rbuf<span class="op">.</span>row_ptr<span class="op">(</span>i<span class="op">)</span> <span class="op">+</span> i <span class="op">*</span> <span class="num">3</span><span class="op">;</span>
        
        <span class="rem">// PutPixel, very sophisticated, huh? :)</span>
        <span class="rem">//-------------</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">127</span><span class="op">;</span> <span class="rem">// R</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">200</span><span class="op">;</span> <span class="rem">// G</span>
        <span class="op">*</span>ptr<span class="op">++</span> <span class="op">=</span> <span class="num">98</span><span class="op">;</span>  <span class="rem">// B</span>
    <span class="op">}</span>

    <span class="rem">// Draw the inner black frame</span>
    <span class="rem">//------------------------</span>
    draw_black_frame<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>

    <span class="rem">// Write to a file</span>
    <span class="rem">//------------------------</span>
    write_ppm<span class="op">(</span>buffer<span class="op">,</span> frame_width<span class="op">,</span> frame_height<span class="op">,</span> <span class="str">"agg_test.ppm"</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> buffer<span class="op">;</span>
    <span class="kw1">return</span> <span class="num">0</span><span class="op">;</span>
<span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
result:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/rendering_buffer3.gif" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>
<table style="margin: 0px;" height="1px" width="640px" bgcolor="#583927"
 border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>And 
the last modification is:
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre>    <span class="rem">// Attach to the part of the buffer, </span>
    <span class="rem">// with 20 pixel margins at each side and negative 'stride'</span>
    rbuf<span class="op">.</span>attach<span class="op">(</span>buffer <span class="op">+</span> 
                  frame_width <span class="op">*</span> <span class="num">3</span> <span class="op">*</span> <span class="num">20</span> <span class="op">+</span>      <span class="rem">// initial Y-offset</span>
                  <span class="num">3</span> <span class="op">*</span> <span class="num">20</span><span class="op">,</span>                     <span class="rem">// initial X-offset</span>
                frame_width <span class="op">-</span> <span class="num">40</span><span class="op">,</span>
                frame_height <span class="op">-</span> <span class="num">40</span><span class="op">,</span>
                <span class="op">-</span>frame_width <span class="op">*</span> <span class="num">3</span>              <span class="rem">// Negate the stride</span>
                <span class="op">)</span><span class="op">;</span>               
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
result:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/rendering_buffer4.gif" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>In 
the last example we just negated the stride value, 
keeping the pointer to the beginning of the buffer as it was in 
the previous example.
</p></td></tr></tbody></table><table class="note" width="640px"><tbody><tr><td><b>NOTE</b><br>
Function <code>write_ppm()</code> writes the pixel map to a file. 
Hereafter it will
be omited in this text, but duplicated when necessary in source code in 
the <code>agg2/tutorial</code> directory.
</td></tr></tbody></table>


<br><h2>Pixel Format Renderers<a name="toc0005"></a></h2>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>First,
 we create another, more civil example, which is in 
<code>agg2/tutorial/t02_pixel_formats</code>:
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw2">#include</span> <span class="op">&lt;</span>stdio<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="op">&lt;</span>string<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="str">"agg_pixfmt_rgb24.h"</span>

<span class="kw1">enum</span>
<span class="op">{</span>
    frame_width <span class="op">=</span> <span class="num">320</span><span class="op">,</span>
    frame_height <span class="op">=</span> <span class="num">200</span>
<span class="op">}</span><span class="op">;</span>

<span class="rem">// [...write_ppm is skipped...]</span>

<span class="rem">// Draw a black frame around the rendering buffer</span>
<span class="rem">//--------------------------------------------------</span>
<span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> Ren<span class="op">&gt;</span>
<span class="kw1">void</span> draw_black_frame<span class="op">(</span>Ren<span class="op">&amp;</span> ren<span class="op">)</span>
<span class="op">{</span>
    <span class="kw1">unsigned</span> i<span class="op">;</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a> c<span class="op">(</span><span class="num">0</span><span class="op">,</span><span class="num">0</span><span class="op">,</span><span class="num">0</span><span class="op">)</span><span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> ren<span class="op">.</span>height<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        ren<span class="op">.</span>copy_pixel<span class="op">(</span><span class="num">0</span><span class="op">,</span>               i<span class="op">,</span> c<span class="op">)</span><span class="op">;</span>
        ren<span class="op">.</span>copy_pixel<span class="op">(</span>ren<span class="op">.</span>width<span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="num">1</span><span class="op">,</span> i<span class="op">,</span> c<span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> ren<span class="op">.</span>width<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        ren<span class="op">.</span>copy_pixel<span class="op">(</span>i<span class="op">,</span> <span class="num">0</span><span class="op">,</span>                c<span class="op">)</span><span class="op">;</span>
        ren<span class="op">.</span>copy_pixel<span class="op">(</span>i<span class="op">,</span> ren<span class="op">.</span>height<span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="num">1</span><span class="op">,</span> c<span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>
<span class="op">}</span>


<span class="kw1">int</span> <span class="kw1">main</span><span class="op">(</span><span class="op">)</span>
<span class="op">{</span>
    <span class="rem">//--------------------</span>
    <span class="rem">// Allocate the buffer.</span>
    <span class="rem">// Clear the buffer, for now "manually"</span>
    <span class="rem">// Create the rendering buffer object</span>
    <span class="rem">// Create the Pixel Format renderer</span>
    <span class="rem">// Do something simple, draw a diagonal line</span>
    <span class="rem">// Write the buffer to agg_test.ppm</span>
    <span class="rem">// Free memory</span>

    <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">[</span>frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">]</span><span class="op">;</span>

    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a> pixf<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>

    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> pixf<span class="op">.</span>height<span class="op">(</span><span class="op">)</span><span class="op">/</span><span class="num">2</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        pixf<span class="op">.</span>copy_pixel<span class="op">(</span>i<span class="op">,</span> i<span class="op">,</span> agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a><span class="op">(</span><span class="num">127</span><span class="op">,</span> <span class="num">200</span><span class="op">,</span> <span class="num">98</span><span class="op">)</span><span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>

    draw_black_frame<span class="op">(</span>pixf<span class="op">)</span><span class="op">;</span>
    write_ppm<span class="op">(</span>buffer<span class="op">,</span> frame_width<span class="op">,</span> frame_height<span class="op">,</span> <span class="str">"agg_test.ppm"</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> buffer<span class="op">;</span>
    <span class="kw1">return</span> <span class="num">0</span><span class="op">;</span>
<span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>This
 example doesn't look very different from the previous one, but the 
difference in its essence is great. Look at the declaration:
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre>agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a> pixf<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Here
 we create a low-level pixel rendering object and attach it to the 
rendering buffer.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>It 
defined as:
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">typedef</span> pixel_formats_rgb24<span class="op">&lt;</span>order_rgb24<span class="op">&gt;</span> <a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>

<a name="pixfmt"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Class
 template pixel_formats_rgb24 has full knowledge about this 
particular pixel format in memory. The only template parameter
can be order_rgb24 or order_bgr24 that determines the order of color
channels.</p></td></tr></tbody></table> 

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Unlike
 <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>,
 these classes operate with integer pixel 
coordinates because they know how to calculate the offset for 
<nobr>particular <b>X</b></nobr>. One can say that it would be easier to
 keep the 
width of the pixel inside the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>,
 but in practice it would be 
a restriction. Don't forget that the width of one pixel in memory can be
 
less than one byte, for example, when rendering high resolution 
B&amp;W images for printers. Thus, there is just a separation of the 
functionality, <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>
 just accelerates access to rows, 
pixel format renderers have knowledge of how to interpret the rows.</p></td></tr></tbody></table>


<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Currently,
 in <b>AGG</b> there are the following files that implement different 
pixel formats:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p></p><ul
 type="disc">
<li>agg_pixfmt_gray8.h, one byte per pixel grayscale buffer. This pixel 
format allows
   you to work with one color component of the rgb24 or rgba32 pixel 
format.
   It has the template parameters <code>Step</code> and <code>Offset</code>
 and for the convenience 
   defines the following types:</li>
<ul type="disc">
<li><code>typedef pixfmt_gray8_base&lt;1, 0&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_gray.h.html#pixfmt_gray8">pixfmt_gray8</a>;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 0&gt; pixfmt_gray8_rgb24r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 1&gt; pixfmt_gray8_rgb24g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 2&gt; pixfmt_gray8_rgb24b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 2&gt; pixfmt_gray8_bgr24r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 1&gt; pixfmt_gray8_bgr24g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;3, 0&gt; pixfmt_gray8_bgr24b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 0&gt; pixfmt_gray8_rgba32r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 1&gt; pixfmt_gray8_rgba32g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 2&gt; pixfmt_gray8_rgba32b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 3&gt; pixfmt_gray8_rgba32a;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 1&gt; pixfmt_gray8_argb32r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 2&gt; pixfmt_gray8_argb32g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 3&gt; pixfmt_gray8_argb32b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 0&gt; pixfmt_gray8_argb32a;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 2&gt; pixfmt_gray8_bgra32r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 1&gt; pixfmt_gray8_bgra32g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 0&gt; pixfmt_gray8_bgra32b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 3&gt; pixfmt_gray8_bgra32a;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 3&gt; pixfmt_gray8_abgr32r;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 2&gt; pixfmt_gray8_abgr32g;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 1&gt; pixfmt_gray8_abgr32b;</code></li>
<li><code>typedef pixfmt_gray8_base&lt;4, 0&gt; pixfmt_gray8_abgr32a;</code></li></ul>
<li>agg_pixfmt_rgb24.h, three bytes per pixel, with RGB or BGR component
 orders. 
   Defines the following pixel format types:</li>
<ul type="disc">
<li><code>typedef pixel_formats_rgb24&lt;order_rgb24&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a>;</code></li>
<li><code>typedef pixel_formats_rgb24&lt;order_bgr24&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_bgr24">pixfmt_bgr24</a>;</code></li></ul>
<li>agg_pixfmt_rgb555.h, 15 bits per pixel, 5 bits per channel. The 
elder bit is unused.</li>
<li>agg_pixfmt_rgb565.h, 16 bits per pixel, 5 bits for Red, 6 bits for 
Green, and 5 bits for Blue.</li>
<li>agg_pixfmt_rgba32.h, four bytes per pixel, RGB plus Alpha with 
different component 
   orders:</li>
<ul type="disc">
<li><code>typedef pixel_formats_rgba32&lt;order_rgba32&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgba.h.html#pixfmt_rgba32">pixfmt_rgba32</a>;</code></li>
<li><code>typedef pixel_formats_rgba32&lt;order_argb32&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgba.h.html#pixfmt_argb32">pixfmt_argb32</a>;</code></li>
<li><code>typedef pixel_formats_rgba32&lt;order_abgr32&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgba.h.html#pixfmt_abgr32">pixfmt_abgr32</a>;</code></li>
<li><code>typedef pixel_formats_rgba32&lt;order_bgra32&gt; <a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_rgba.h.html#pixfmt_bgra32">pixfmt_bgra32</a>;</code></li></ul></ul><p></p></td></tr></tbody></table>


<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
pixel format classes define their native color space and the color type,
 
for example:
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">typedef</span> <a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a> color_type<span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>For <code>pixfmt_gray8_nnn</code>
 it's <a 
href="http://www.antigrain.com/__code/include/agg_color_gray.h.html#gray8">gray8</a>.
 This mechanism allows you to write 
your own pixel and color formats, for example, HSV, CMYK, and so on. 
The rest of the library will work with new pixel formats in exactly 
same way as with currently implemented ones. 
</p></td></tr></tbody></table><table class="note" width="640px"><tbody><tr><td><b>NOTE</b><br>
It's very important not to confuse the color type that the pixel format
renderer works with and the <b>native</b> color space that the buffer
represents. For example, you can pretend that you work with the CMYK 
color
space using the RGB buffer (you just write a simple conversion function 
that 
creates an <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
 object from some CMYK structure). But it will be only
an imitation and you will have color losses, because there are some 
colors in CMYK that cannot be displayed with RGB and vice versa. 
To use the capabilities of some color space completely one has to write
a pixel format renderer for that particular color space and to work
in that color space without any intermediate conversions.
</td></tr></tbody></table>

<h3>Creation<a name="toc0006"></a></h3>

<table class="warning" width="640px"><tbody><tr><td><b>IMPORTANT!</b><br>
The pixel format classes do not perform any clipping operations, which 
means that 
working directly with these classes is generally unsafe. Clipping is the
 
functionality of higher level classes. The reason of this design is 
simple &#8212;
it must be as easy as possible to write your own pixel format classes. 
There 
can be many of them while the clipping code remains exactly the same.
</td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre>pixel_formats_rgb24<span class="op">(</span><a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">&amp;</span> rb<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
constructor of the pixel format renderers expects a reference to the 
created and fully initialized <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>.
 The cost of creation 
is minimal, basically it's initializing of one pointer.</p></td></tr></tbody></table>

<h3>Member Functions<a name="toc0007"></a></h3>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
pixel format renderers must expose the following functionality 
(interface).</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">unsigned</span> width<span class="op">(</span><span class="op">)</span>  <span class="kw1">const</span> <span class="op">{</span> <span class="kw1">return</span> m_rbuf<span class="op">-</span><span class="op">&gt;</span>width<span class="op">(</span><span class="op">)</span><span class="op">;</span>  <span class="op">}</span>
<span class="kw1">unsigned</span> height<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span> <span class="op">{</span> <span class="kw1">return</span> m_rbuf<span class="op">-</span><span class="op">&gt;</span>height<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">}</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 width and height of the buffer in pixels.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre>color_type pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 the color value of the pixel with coordinates <code>(x,y)</code>. 
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Copies
 a pixel of color <code>c</code> to the buffer as it is. In the RGB 
pixel formats it doesn't consider the alpha channel existing in the <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
type, in RGBA &#8212; it simply copies the alpha value to the buffer together 
with R, G, and B.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blends
 a pixel of color <code>c</code> with the one in the buffer. 
Now it's time to explain the concept of blending. Blending is a key
feature for <b><nobr>Anti-Aliasing</nobr></b>. In the RGBA color space 
we use the <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
 structure to represent
colors. The structure already has data member <code><a 
href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a>
 a;</code> that is the alpha 
channel. But in this function we also see argument <code>cover</code> 
that deterines 
the coverage value for the pixel, i.e, the part of the pixel that is
&#8220;covered&#8221; by the polygon. In fact, you can interpret it as a second 
"Alpha"
("Beta"?). There are two reasons to do so. First of all, the color type
doesn't have to contain the alpha value. The second, even if the 
color type has the Alpha field, its type doesn't have to be compatible
with the ones used in <b><nobr>Anti-Aliasing</nobr></b> algorithms. 
Suppose you work with a &#8220;Hi-End&#8221;
RGBA color space represented as four floats in range [0&#8230;1]. Its alpha 
value is also of type float &#8212; one byte is too bad for general blending
in this case, but quite enough for <b><nobr>Anti-Aliasing</nobr></b>. So
 that, the <code>cover</code> value is 
just a unified secondary alpha used specifically for <b><nobr>Anti-Aliasing</nobr></b>
 purposes.
Globally, it's defined as <a 
href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a>,
 but in the described rasterizers
there explicit <a 
href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a>
 type is used. It's done intentionally, because
if there's a necessity to increase the capacity of <a 
href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a>,
all the existing pixel format rasterizres become incompatible with
the <a 
href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a>.
 They will be <b>actually</b> incompatible, in fact, 8-bit
coverage values plus 8-bit alpha is the maximum that fits 32-bit 
intermediate results when blending colors. In case of 16-bit values
we will have to use 64-bit integers, which is very expensive on 32-bit 
platforms.
<br><br></p></td></tr></tbody></table>
 
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_hline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_vline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a horizontal or a vertical line of certain color.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_hline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_vline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a horizontal or a vertical line of certain color. The reason to 
separate
&#8220;copy&#8221; and &#8220;blend&#8221; versions is the performance. Of course, there can be 
one
extra <code>if/else</code> statement (and there is, in the &#8220;blend&#8221; 
versions), but still, 
it becomes critical when using <code>hline/vline</code> to draw many of 
small markers, 
like in different scatter plot applications.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_solid_hspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_solid_vspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a horizontal or a vertical solid-color span. Span is almost the same as
 
<code>hline/vline</code>, but there's an array of the coverage values. 
These
functions are used when rendering solid Anti-Aliased polygons.
<br><br></p></td></tr></tbody></table>


<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_color_hspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_color_vspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">unsigned</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a horizontal or a vertical color span. The functions are used 
with different span generators, such as gradients, images, patterns, 
Gouraud interpolation, etc. They accept an array of colors whose type 
must be compatible with the used pixel format. For example, all 
existing RGB pixel formats are compatible with the <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
 type. 
Argument <b>covers</b> is an array of the coverage values as in the 
<code>blend_solid_hspan</code>. It's optional and can be 0.
<br><br></p></td></tr></tbody></table>


<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Another
 example is drawing of the solar spectrum. Class <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba">rgba</a>,
 that keeps four 
components as doubles, has static method <code>from_wavelength</code> 
and the respective 
constructor, class <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
 can be constructed from <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba">rgba</a>
 (it's a common policy
in <b>AGG</b> that any color type can be constructed from the <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba">rgba</a>
 type). We will use it.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw2">#include</span> <span class="op">&lt;</span>stdio<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="op">&lt;</span>string<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="str">"agg_pixfmt_rgb24.h"</span>

<span class="kw1">enum</span>
<span class="op">{</span>
    frame_width <span class="op">=</span> <span class="num">320</span><span class="op">,</span>
    frame_height <span class="op">=</span> <span class="num">200</span>
<span class="op">}</span><span class="op">;</span>

<span class="rem">// [...write_ppm is skipped...]</span>

<span class="kw1">int</span> <span class="kw1">main</span><span class="op">(</span><span class="op">)</span>
<span class="op">{</span>
    <span class="rem">//--------------------</span>
    <span class="rem">// Allocate the buffer.</span>
    <span class="rem">// Clear the buffer, for now "manually"</span>
    <span class="rem">// Create the rendering buffer object</span>
    <span class="rem">// Create the Pixel Format renderer</span>
    <span class="rem">// Create one line (span) of type <a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>.</span>
    <span class="rem">// Fill the buffer using blend_color_span</span>
    <span class="rem">// Write the buffer to agg_test.ppm</span>
    <span class="rem">// Free memory</span>

    <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">[</span>frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">]</span><span class="op">;</span>

    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a> pixf<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>

    agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a> span<span class="op">[</span>frame_width<span class="op">]</span><span class="op">;</span>

    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> frame_width<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba">rgba</a> c<span class="op">(</span><span class="num">380</span><span class="op">.</span><span class="num">0</span> <span class="op">+</span> <span class="num">400</span><span class="op">.</span><span class="num">0</span> <span class="op">*</span> i <span class="op">/</span> frame_width<span class="op">,</span> <span class="num">0</span><span class="op">.</span><span class="num">8</span><span class="op">)</span><span class="op">;</span>
        span<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a><span class="op">(</span>c<span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>

    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> frame_height<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        pixf<span class="op">.</span>blend_color_hspan<span class="op">(</span><span class="num">0</span><span class="op">,</span> i<span class="op">,</span> frame_width<span class="op">,</span> span<span class="op">,</span> <span class="num">0</span><span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>


    write_ppm<span class="op">(</span>buffer<span class="op">,</span> frame_width<span class="op">,</span> frame_height<span class="op">,</span> <span class="str">"agg_test.ppm"</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> buffer<span class="op">;</span>
    <span class="kw1">return</span> <span class="num">0</span><span class="op">;</span>
<span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Here
 is the result:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/spectrum.png" title="" border="0"><br><i></i></center></td></tr></tbody></table>


<h3>Alpha-Mask Adaptor<a name="toc0008"></a></h3>

<a name="pixfmt_amask_adaptor"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Alpha-mask
 is a separate buffer that is usually used to 
perform clipping to an arbitrary shape at the low level. 
There is a special adapter class that passes all calls to pixel format 
renderes
through the alpha-mask filter. Usually alpha-mask is a gray scale buffer
 
(one byte per pixel) of the same size as the main rendering buffer. Each
pixel in the alpha-mask deternines an additional pixel coverage value 
that 
is mixed with the main one. Functions like <code>copy_hline()</code>, 
that do not 
have a coverage value argument translate the calls to the respective 
functions with this argument. For example, <code>copy_hline()</code> 
takes the 
horizontal span from the alpha mask buffer and then calls 
<code>blend_solid_hspan()</code>.</p></td></tr></tbody></table> 

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Include
 files:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p><code>#include
 "<a 
href="http://www.antigrain.com/__code/include/agg_pixfmt_amask_adaptor.h.html">agg_pixfmt_amask_adaptor.h</a>"<br>
#include "<a 
href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html">agg_alpha_mask_u8.h</a>"<br></code></p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Below
 is an example of how to declare the pixel format renderer with the 
alpha-mask adaptor.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw2">#include</span> <span class="str">"agg_pixfmt_rgb24.h"</span>
<span class="kw2">#include</span> <span class="str">"<a href="http://www.antigrain.com/__code/include/agg_pixfmt_amask_adaptor.h.html">agg_pixfmt_amask_adaptor.h</a>"</span>
<span class="kw2">#include</span> <span class="str">"<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html">agg_alpha_mask_u8.h</a>"</span>

<span class="rem">//. . .</span>

    <span class="rem">// Allocate the alpha-mask buffer, create the rendering buffer object</span>
    <span class="rem">// and create the alpha-mask object.</span>
    <span class="rem">//--------------------------------</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> amask_buf <span class="op">=</span> <span class="kw1">new</span> agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">[</span>frame_width <span class="op">*</span> frame_height<span class="op">]</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> amask_rbuf<span class="op">(</span>amask_buf<span class="op">,</span> 
                                     frame_width<span class="op">,</span> 
                                     frame_height<span class="op">,</span> 
                                     frame_width<span class="op">)</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#amask_no_clip_gray8">amask_no_clip_gray8</a> amask<span class="op">(</span>amask_rbuf<span class="op">)</span><span class="op">;</span>

    <span class="rem">// Create the alpha-mask adaptor attached to the alpha-mask object</span>
    <span class="rem">// and the pixel format renderer. Here pixf is a previously</span>
    <span class="rem">// created pixel format renderer of type agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a>.</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#pixfmt_amask_adaptor">pixfmt_amask_adaptor</a><span class="op">&lt;</span>agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a><span class="op">,</span> 
                              agg::<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#amask_no_clip_gray8">amask_no_clip_gray8</a><span class="op">&gt;</span> pixf_amask<span class="op">(</span>pixf<span class="op">,</span> amask<span class="op">)</span><span class="op">;</span>
    <span class="rem">//. . .</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Note
 that here we use <a 
href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#amask_no_clip_gray8">amask_no_clip_gray8</a>
 that doesn't perform clipping.
It's because we use the main and the alpha-mask buffers of exactly same 
size, 
so, if there are no memory violations in the main rendering buffer, 
there 
will be no memory violations in the alpha mask buffer either. Clipping
is performed at the higher level. If your alpha-mask buffer is less than
 
the main one you will have to use <a 
href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#alpha_mask_gray8">alpha_mask_gray8</a>
 instead.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Below
 is a complete example.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw2">#include</span> <span class="op">&lt;</span>stdio<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="op">&lt;</span>string<span class="op">.</span>h<span class="op">&gt;</span>
<span class="kw2">#include</span> <span class="str">"agg_pixfmt_rgb24.h"</span>
<span class="kw2">#include</span> <span class="str">"<a href="http://www.antigrain.com/__code/include/agg_pixfmt_amask_adaptor.h.html">agg_pixfmt_amask_adaptor.h</a>"</span>
<span class="kw2">#include</span> <span class="str">"<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html">agg_alpha_mask_u8.h</a>"</span>

<span class="kw1">enum</span>
<span class="op">{</span>
    frame_width <span class="op">=</span> <span class="num">320</span><span class="op">,</span>
    frame_height <span class="op">=</span> <span class="num">200</span>
<span class="op">}</span><span class="op">;</span>

<span class="rem">// [...write_ppm is skipped...]</span>

<span class="kw1">int</span> <span class="kw1">main</span><span class="op">(</span><span class="op">)</span>
<span class="op">{</span>
    <span class="rem">// Allocate the main rendering buffer and clear it, for now "manually",</span>
    <span class="rem">// and create the <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> object and the pixel format renderer</span>
    <span class="rem">//--------------------------------</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">[</span>frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">]</span><span class="op">;</span>
    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a> pixf<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>


    <span class="rem">// Allocate the alpha-mask buffer, create the rendering buffer object</span>
    <span class="rem">// and create the alpha-mask object.</span>
    <span class="rem">//--------------------------------</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">*</span> amask_buf <span class="op">=</span> <span class="kw1">new</span> agg::<a href="http://www.antigrain.com/__code/include/agg_basics.h.html#int8u">int8u</a><span class="op">[</span>frame_width <span class="op">*</span> frame_height<span class="op">]</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> amask_rbuf<span class="op">(</span>amask_buf<span class="op">,</span> 
                                     frame_width<span class="op">,</span> 
                                     frame_height<span class="op">,</span> 
                                     frame_width<span class="op">)</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#amask_no_clip_gray8">amask_no_clip_gray8</a> amask<span class="op">(</span>amask_rbuf<span class="op">)</span><span class="op">;</span>

    <span class="rem">// Create the alpha-mask adaptor attached to the alpha-mask object</span>
    <span class="rem">// and the pixel format renderer</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#pixfmt_amask_adaptor">pixfmt_amask_adaptor</a><span class="op">&lt;</span>agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a><span class="op">,</span> 
                              agg::<a href="http://www.antigrain.com/__code/include/agg_alpha_mask_u8.h.html#amask_no_clip_gray8">amask_no_clip_gray8</a><span class="op">&gt;</span> pixf_amask<span class="op">(</span>pixf<span class="op">,</span> amask<span class="op">)</span><span class="op">;</span>


    <span class="rem">// Draw something in the alpha-mask buffer. </span>
    <span class="rem">// In this case we fill the buffer with a simple verical gradient</span>
    <span class="kw1">unsigned</span> i<span class="op">;</span>
    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> frame_height<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        <span class="kw1">unsigned</span> val <span class="op">=</span> <span class="num">255</span> <span class="op">*</span> i <span class="op">/</span> frame_height<span class="op">;</span>
        memset<span class="op">(</span>amask_rbuf<span class="op">.</span>row_ptr<span class="op">(</span>i<span class="op">)</span><span class="op">,</span> val<span class="op">,</span> frame_width<span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>


    <span class="rem">// Draw the spectrum, write a .ppm and free memory</span>
    <span class="rem">//----------------------</span>
    agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a> span<span class="op">[</span>frame_width<span class="op">]</span><span class="op">;</span>

    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> frame_width<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba">rgba</a> c<span class="op">(</span><span class="num">380</span><span class="op">.</span><span class="num">0</span> <span class="op">+</span> <span class="num">400</span><span class="op">.</span><span class="num">0</span> <span class="op">*</span> i <span class="op">/</span> frame_width<span class="op">,</span> <span class="num">0</span><span class="op">.</span><span class="num">8</span><span class="op">)</span><span class="op">;</span>
        span<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> agg::<a href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a><span class="op">(</span>c<span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>

    <span class="kw1">for</span><span class="op">(</span>i <span class="op">=</span> <span class="num">0</span><span class="op">;</span> i <span class="op">&lt;</span> frame_height<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span>
    <span class="op">{</span>
        pixf_amask<span class="op">.</span>blend_color_hspan<span class="op">(</span><span class="num">0</span><span class="op">,</span> i<span class="op">,</span> frame_width<span class="op">,</span> span<span class="op">,</span> <span class="num">0</span><span class="op">)</span><span class="op">;</span>
    <span class="op">}</span>

    write_ppm<span class="op">(</span>buffer<span class="op">,</span> frame_width<span class="op">,</span> frame_height<span class="op">,</span> <span class="str">"agg_test.ppm"</span><span class="op">)</span><span class="op">;</span>

    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> amask_buf<span class="op">;</span>
    <span class="kw1">delete</span> <span class="op">[</span><span class="op">]</span> buffer<span class="op">;</span>
    <span class="kw1">return</span> <span class="num">0</span><span class="op">;</span>
<span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>And 
the result:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/spectrum_amask1.png" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Note
 that we cleared the main buffer with the white color. Now change 
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre>    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">255</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>to
</p></td></tr></tbody></table><table width="640px" border="0" 
cellpadding="0" cellspacing="0"><tbody><tr><td><pre>    memset<span class="op">(</span>buffer<span class="op">,</span> <span class="num">0</span><span class="op">,</span> frame_width <span class="op">*</span> frame_height <span class="op">*</span> <span class="num">3</span><span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
result:</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td><center><img 
src="basic_renderers.agdoc_files/spectrum_amask2.png" title="" 
border="0"><br><i></i></center></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>In 
other words, the alpha-mask works as a separete alpha-channel
mixed with rendered primitives.
The fact that it contains 8-bit values allows you to clip 
all drawing to arbitrary shapes with perfect <b><nobr>Anti-Aliasing</nobr></b>.</p></td></tr></tbody></table>


<br><h2>Basic Renderers<a name="toc0009"></a></h2>

<a name="renderer_base"><b></b></a> <a name="renderer_mclip"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>There
 are two basic renderers with almost the same functionality: 
<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 and <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>.
 The first one is used most often
and it performs low level clipping. Clipping in general is a 
complex task. In <b>AGG</b> there can be at least two levels of 
clipping, 
the low (pixel) level, and the high (vectorial) level. These classes
perform the pixel level clipping to protect the buffer from 
<nobr>out-of-bound</nobr> memory access. Class <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 performs
clipping to multi-rectangle clipping areas, but its performance 
depends on the number of clipping rectangles.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p><a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 and <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 are class templates parametrized 
with a pixel format renderer:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> PixelFormat<span class="op">&gt;</span> <span class="kw1">class</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
<span class="op">{</span>
<span class="kw1">public</span>:
    <span class="kw1">typedef</span> PixelFormat pixfmt_type<span class="op">;</span>
    <span class="kw1">typedef</span> <span class="kw1">typename</span> pixfmt_type::color_type color_type<span class="op">;</span>

    <span class="op">.</span> <span class="op">.</span> <span class="op">.</span>
<span class="op">}</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>See 
sources <a 
href="http://www.antigrain.com/__code/include/agg_renderer_base.h.html#renderer_base">renderer_base</a>
 <a 
href="http://www.antigrain.com/__code/include/agg_renderer_mclip.h.html#renderer_mclip">renderer_mclip</a></p></td></tr></tbody></table>

<h3>Creation<a name="toc0010"></a></h3>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a><span class="op">(</span>pixfmt_type<span class="op">&amp;</span> ren<span class="op">)</span><span class="op">;</span>
<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a><span class="op">(</span>pixfmt_type<span class="op">&amp;</span> ren<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Both
 classes accept a reference to the pixel format renderer. 
<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 uses <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>&lt;PixelFormat&gt;
 inside itself to 
perform implemented clipping to a single rectangle region.
Note that you can use <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#pixfmt_amask_adaptor">pixfmt_amask_adaptor</a>
 as <code>PixelFormat</code>
template parameter.</p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
cost of creation is minimal, it's just initializing of the class
member variables. But <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 allocates memory when you 
add new clipping rectangles and deallocates it when destroying. 
It uses the pod_deque class that allocates blocks of memory of equal 
size and never reallocates it. When you reset clipping, the memory 
is not deallocated, it's reused. The <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 deallocates 
memory only when destroying. This technique is widely used in <b>AGG</b>
 
and prevents from deep memory fragmentation.</p></td></tr></tbody></table>
 

<h3>Member Functions<a name="toc0011"></a></h3>
          
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">const</span> pixfmt_type<span class="op">&amp;</span> ren<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
pixfmt_type<span class="op">&amp;</span> ren<span class="op">(</span><span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 a reference to the pixel format renderer.          
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">unsigned</span> width<span class="op">(</span><span class="op">)</span>  <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">unsigned</span> height<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 width and height of the rendering buffer.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> reset_clipping<span class="op">(</span><span class="kw1">bool</span> visibility<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
function resets the clipping. If the <code>visibility</code> is <code>true</code>
 the 
clipping box is set to <code>(0, 0, width()-1, height()-1)</code>, if <code>false</code>,
it sets an invisible box, i.e., <code>(1,1,0,0)</code>. In <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 this 
function also removes all the clipping areas that were previously
added.
</p></td></tr></tbody></table><table class="warning" width="640px"><tbody><tr><td><b>IMPORTANT!</b><br>
If you attach another memory buffer to the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a>,
 connected
with this particular basic renderer, you <b>must</b> call 
<code>reset_clipping</code>, otherwise, the clipping box will be not 
valid.
It's because there's no any &#8220;feedback&#8221; from
the rendering buffer to the renderers, in other words, <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 
and <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 don't know anything if the rendering buffer is 
changed. Having some mechanism of events or delegates would be 
an overkill in this case.</td></tr></tbody></table>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">bool</span> clip_box<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Set 
new clipping box. Only <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 has this function.
The clipping box <b>includes</b> the boundaries, so that, the maximal
one is <code>(0, 0, width()-1, height()-1)</code>. The clipping box 
is clipped to the maximal value before setting, so that, it's
safe to set a box bigger than <code>(0, 0, width()-1, height()-1)</code>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> add_clip_box<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Add 
new clipping box. Only <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 has this function. 
You can add any number of rectangular regions, but they must not
overlap. In case of overlapping areas, some elements can be drawn
twice or more. The clipping boxes are being clipped by the bounding 
box <code>(0, 0, width()-1, height()-1)</code> before adding, which is 
done
for the sake of efficiency. It also means that calling 
<code>reset_clipping(false)</code> for the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 doesn't make
any sense because all adding regions will be clipped by an 
invisible area and will not be actually added. The visible areas
also includes the boundaries of the boxes, that is, 
<code>add_clip_box(100,100,100,100)</code> will add a clipping region
of 1 pixel size.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> clip_box_naked<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Only
 <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 has this function. Set new clipping box without 
clipping to the rendering buffer size. This function is unsafe 
and used in the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 for fast switching between
partial regions when rendering. The purpose of this function
is just to avoid extra overhead.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">bool</span> inbox<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">)</span> <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Check
 if point <code>(x, y)</code> is inside of the clipping box.
Only <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 has this function. 
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> first_clip_box<span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="kw1">bool</span> next_clip_box<span class="op">(</span><span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>These
 two functions are used to enumerate all the clipping regions
of the renderer. In the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 class they are empty, 
<code>next_clip_box()</code> always return false.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">const</span> rect<span class="op">&amp;</span> clip_box<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         xmin<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         ymin<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         xmax<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         ymax<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 the clipping box as a rectangle and as separate integer
values. In <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 the functions always return
<code>(0, 0, width()-1, height()-1)</code>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">const</span> rect<span class="op">&amp;</span> bounding_clip_box<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         bounding_xmin<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         bounding_ymin<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         bounding_xmax<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">int</span>         bounding_ymax<span class="op">(</span><span class="op">)</span>     <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 the bounding clipping box as a rectangle and as separate 
integer values. In <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 the functions always return
the same values as the respective ones from the previous group.
In <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>
 they return the bounding box calculated 
on the basis of added regions.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> clear<span class="op">(</span><span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Clears
 the buffer with the given color without clipping.
<br><br></p></td></tr></tbody></table>
          
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Set a
 pixel with clipping.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a pixel with clipping. The behavior is the same as in the pixel
format renderers (<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#pixfmt">pixfmt</a>).
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre>color_type pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">)</span> <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 the value of the pixel with coordinates <code>(x, y)</code>. If the 
point
is clipped, the function returns <code>color_type::no_color()</code>. 
For <a 
href="http://www.antigrain.com/__code/include/agg_color_rgba.h.html#rgba8">rgba8</a>
it's <code>(0,0,0,0)</code>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_hline<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> copy_vline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span>

<span class="kw1">void</span> blend_hline<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> 
                 <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a> cover<span class="op">)</span><span class="op">;</span>

<span class="kw1">void</span> blend_vline<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">,</span> 
                 <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 (copy) or blend horizontal or vertical line of pixels.
The behaviour is the same as in pixel format renders
(<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#pixfmt">pixfmt</a>),
 but here you use coordinates of the begin and end 
of the lines instead of <code>(x, y, length)</code>. 
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_bar<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> blend_bar<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">,</span> 
               <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a> cover<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 (copy) or blend a solid bar (rectangle). 
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_solid_hspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span>

<span class="kw1">void</span> blend_solid_vspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a horizontal or a vertical solid-color span. 
These functions are used when rendering solid Anti-Aliased polygons. 
<br><br></p></td></tr></tbody></table>


<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_color_hspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span>

<span class="kw1">void</span> blend_color_vspan<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                       <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Blend
 a horizontal or a vertical color span. The functions are used with 
different span generators, such as gradients, images, patterns, 
Gouraud interpolation, etc. They accept an array of colors whose 
type must be compatible with the used pixel format.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> blend_color_hspan_no_clip<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                               <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> 
                               <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span>

<span class="kw1">void</span> blend_color_vspan_no_clip<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> len<span class="op">,</span> 
                               <span class="kw1">const</span> color_type<span class="op">*</span> colors<span class="op">,</span> 
                               <span class="kw1">const</span> <a href="http://www.antigrain.com/__code/include/agg_basics.h.html#cover_type">cover_type</a><span class="op">*</span> covers<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
same as above, but without clipping. These functions are
used in the scanline renderers. The reason to do so is the performance.
Tne scanline consists of a number of spans and it's a little bit 
more efficient to perform clipping when we have information about
the whole scanline rather than to clip every span, especially in 
<a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> copy_from<span class="op">(</span><span class="kw1">const</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">&amp;</span> from<span class="op">,</span> 
               <span class="kw1">const</span> rect<span class="op">*</span> rc<span class="op">=</span><span class="num">0</span><span class="op">,</span> 
               <span class="kw1">int</span> x_to<span class="op">=</span><span class="num">0</span><span class="op">,</span> 
               <span class="kw1">int</span> y_to<span class="op">=</span><span class="num">0</span><span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Copy
 a rectangular area of the buffer <code>from</code> to <code>this</code>
 one
considering clipping.
It's assumed that the rendering buffer <code>from</code> has the same 
pixel format as the destination <code>(this)</code> one. <code>rc</code>
 is an 
optional rectangle in the <code>from</code> buffer, <code>x_to</code> 
and <code>y_to</code> &#8212;
the coordinates of the <code>rc-&gt;x1, rc-&gt;y1</code> mapped to the 
destination 
buffer. 
<br><br></p></td></tr></tbody></table>



<h3>A common example<a name="toc0012"></a></h3>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
code below is a very common example of declaring and using 
of the rendring buffer and low level renderers.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre>    <span class="rem">// Typedefs of the low level renderers to simplify the declarations.</span>
    <span class="rem">// Here you can use any other pixel format renderer and</span>
    <span class="rem">// agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a> if necessary.</span>
    <span class="rem">//--------------------------</span>
    <span class="kw1">typedef</span> agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a>                     pixfmt_type<span class="op">;</span>
    <span class="kw1">typedef</span> agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a><span class="op">&lt;</span>agg::<a href="http://www.antigrain.com/__code/include/agg_pixfmt_rgb.h.html#pixfmt_rgb24">pixfmt_rgb24</a><span class="op">&gt;</span> renbase_type<span class="op">;</span>
    <span class="kw1">enum</span> <span class="op">{</span> bytes_per_pixel <span class="op">=</span> <span class="num">3</span> <span class="op">}</span><span class="op">;</span>

    <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">*</span> buffer <span class="op">=</span> <span class="kw1">new</span> <span class="kw1">unsigned</span> <span class="kw1">char</span><span class="op">[</span>frame_width <span class="op">*</span> 
                                              frame_height <span class="op">*</span> 
                                              bytes_per_pixel<span class="op">]</span><span class="op">;</span>
    agg::<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a> rbuf<span class="op">(</span>buffer<span class="op">,</span> 
                               frame_width<span class="op">,</span> 
                               frame_height<span class="op">,</span> 
                               frame_width <span class="op">*</span> bytes_per_pixel<span class="op">)</span><span class="op">;</span>
    
    pixfmt_type pixf<span class="op">(</span>rbuf<span class="op">)</span><span class="op">;</span>
    renbase_type rbase<span class="op">(</span>pixf<span class="op">)</span><span class="op">;</span>

    rbase<span class="op">.</span>clear<span class="op">(</span>clear_color<span class="op">)</span><span class="op">;</span>
    
    <span class="rem">//. . .</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>At 
last we can clear the buffer with certain color instead of 
&#8220;manual&#8221; calling of <code>memset()</code> :-).
Also note that unlike these examples, the <code>stride</code> value is 
not 
obligatory equal to <code>frame_width * bytes_per_pixel</code>. Most 
often 
there will be some alignment requiremants, for example, the width 
of Windows bitmaps must be a multiple of 4 bytes.</p></td></tr></tbody></table>
 








<br><h2>Primitives and Markers Renderers<a name="toc0013"></a></h2>


<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
primitives and marker renderers were added to <b>AGG</b> to provide you a
 
mecahnism of fast drawing regular, aliased objects, such as lines, 
rectangles, and ellipses. The marker renderer can draw some shapes
commonly used in different scatter plots. If you are not going to use
it just skip this section.</p></td></tr></tbody></table>

<h3>Primitives Renderer<a name="toc0014"></a></h3>

<a name="renderer_primitives"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
header file: <a 
href="http://www.antigrain.com/__code/include/agg_renderer_primitives.h.html">agg_renderer_primitives.h</a></p></td></tr></tbody></table>

<h4>Declaration<a name="toc0015"></a></h4>
<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> BaseRenderer<span class="op">&gt;</span> <span class="kw1">class</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a>
<span class="op">{</span>
<span class="kw1">public</span>:
    <span class="kw1">typedef</span> BaseRenderer base_ren_type<span class="op">;</span>
    <span class="kw1">typedef</span> <span class="kw1">typename</span> base_ren_type::color_type color_type<span class="op">;</span>
    <span class="rem">//. . .</span>
<span class="op">}</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Here
 class RendererBase can be of type <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_base">renderer_base</a>
 or <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_mclip">renderer_mclip</a>.</p></td></tr></tbody></table>

<h4>Creation<a name="toc0016"></a></h4>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a><span class="op">(</span>base_ren_type<span class="op">&amp;</span> ren<span class="op">)</span> :
    m_ren<span class="op">(</span><span class="op">&amp;</span>ren<span class="op">)</span><span class="op">,</span>
    m_fill_color<span class="op">(</span><span class="op">)</span><span class="op">,</span>
    m_line_color<span class="op">(</span><span class="op">)</span><span class="op">,</span>
    m_curr_x<span class="op">(</span><span class="num">0</span><span class="op">)</span><span class="op">,</span>
    m_curr_y<span class="op">(</span><span class="num">0</span><span class="op">)</span>
<span class="op">{</span><span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
cost of creation is minimal, it's only initialization of the pointer
to the base renderer object, two colors and initial coordinates that are
 
used in <code>move_to</code> and <code>line_to</code> functions.</p></td></tr></tbody></table>

<h4>Member functions<a name="toc0017"></a></h4>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">static</span> <span class="kw1">int</span> coord<span class="op">(</span><span class="kw1">double</span> c<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Converts
 a coordinate of the <code>double</code> type to integer one with 
subpixel accuracy. It just multiplies the value to 256 (by default) 
and returns the integer part.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> fill_color<span class="op">(</span><span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> line_color<span class="op">(</span><span class="kw1">const</span> color_type<span class="op">&amp;</span> c<span class="op">)</span><span class="op">;</span>
<span class="kw1">const</span> color_type<span class="op">&amp;</span> fill_color<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span>
<span class="kw1">const</span> color_type<span class="op">&amp;</span> line_color<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Set 
and get the fill and line colors. The colors may have
the alpha value that will take effect, i.e., the primitives
will be alpha-blended.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> rectangle<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a rectangle without filling with the line color. 
There are regular, pixel coordinates are used. 
The width of the border is always 1 pixel and cannot 
be changed.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> solid_rectangle<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a filled rectangle without border with the fill color.
The coordinates are in pixels.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> outlined_rectangle<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a filled rectangle with a border. There are both colors
line and fill are used.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> <a href="http://www.antigrain.com/__code/include/agg_ellipse.h.html#ellipse">ellipse</a><span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> rx<span class="op">,</span> <span class="kw1">int</span> ry<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> solid_ellipse<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> rx<span class="op">,</span> <span class="kw1">int</span> ry<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> outlined_ellipse<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> rx<span class="op">,</span> <span class="kw1">int</span> ry<span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 ellipses, non-filled, filled and filled with a border.
The coordinates are integer, in pixels. <code>rx</code> and <code>ry</code>
 &#8212;
radii in pixels. 
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> line<span class="op">(</span><span class="kw1">int</span> x1<span class="op">,</span> <span class="kw1">int</span> y1<span class="op">,</span> <span class="kw1">int</span> x2<span class="op">,</span> <span class="kw1">int</span> y2<span class="op">,</span> <span class="kw1">bool</span> last<span class="op">=</span><span class="kw1">false</span><span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a bresenham line with <b>Subpixel Accuracy</b>. The coordinates are in 
integer format of 24.8, that is, in the 1/256 pixel units.
Flag <code>last</code> defines whether or not to draw the last pixel,
which is important when drawing consecutive line segments with
alpha-blending. There no pixels should be drawn more than once.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> move_to<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> line_to<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">bool</span> last<span class="op">=</span><span class="kw1">false</span><span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
version of <code>line()</code>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">const</span> base_ren_type<span class="op">&amp;</span> ren<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span> <span class="op">{</span> <span class="kw1">return</span> <span class="op">*</span>m_ren<span class="op">;</span> <span class="op">}</span>        
base_ren_type<span class="op">&amp;</span> ren<span class="op">(</span><span class="op">)</span> <span class="op">{</span> <span class="kw1">return</span> <span class="op">*</span>m_ren<span class="op">;</span> <span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 a reference to the base renderer object.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">const</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">&amp;</span> rbuf<span class="op">(</span><span class="op">)</span> <span class="kw1">const</span> <span class="op">{</span> <span class="kw1">return</span> m_ren<span class="op">-</span><span class="op">&gt;</span>rbuf<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">}</span>
<a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#rendering_buffer">rendering_buffer</a><span class="op">&amp;</span> rbuf<span class="op">(</span><span class="op">)</span> <span class="op">{</span> <span class="kw1">return</span> m_ren<span class="op">-</span><span class="op">&gt;</span>rbuf<span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Returns
 a reference to the rendering buffer attached to the base renderer.</p></td></tr></tbody></table>



<h3>Marker Renderer<a name="toc0018"></a></h3>

<a name="renderer_markers"><b></b></a>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
header file: <a 
href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html">agg_renderer_markers.h</a></p></td></tr></tbody></table>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>The 
marker renderer can draw or alpha-blend the following simple shapes:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">enum</span> <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a>
<span class="op">{</span>
    marker_square<span class="op">,</span>
    marker_diamond<span class="op">,</span>
    marker_circle<span class="op">,</span>
    marker_crossed_circle<span class="op">,</span>
    marker_semiellipse_left<span class="op">,</span>
    marker_semiellipse_right<span class="op">,</span>
    marker_semiellipse_up<span class="op">,</span>
    marker_semiellipse_down<span class="op">,</span>
    marker_triangle_left<span class="op">,</span>
    marker_triangle_right<span class="op">,</span>
    marker_triangle_up<span class="op">,</span>
    marker_triangle_down<span class="op">,</span>
    marker_four_rays<span class="op">,</span>
    marker_cross<span class="op">,</span>
    marker_x<span class="op">,</span>
    marker_dash<span class="op">,</span>
    marker_dot<span class="op">,</span>
    marker_pixel
<span class="op">}</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font><table
 width="640px"><tbody><tr><td style="text-align: justify;"><p>&nbsp;</p></td></tr></tbody></table>

<h4>Declaration<a name="toc0019"></a></h4>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> BaseRenderer<span class="op">&gt;</span> <span class="kw1">class</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_markers">renderer_markers</a> :
<span class="kw1">public</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a><span class="op">&lt;</span>BaseRenderer<span class="op">&gt;</span>
<span class="op">{</span>
<span class="kw1">public</span>:
    <span class="kw1">typedef</span> <a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a><span class="op">&lt;</span>BaseRenderer<span class="op">&gt;</span> base_type<span class="op">;</span>
    <span class="kw1">typedef</span> BaseRenderer base_ren_type<span class="op">;</span>
    <span class="kw1">typedef</span> <span class="kw1">typename</span> base_ren_type::color_type color_type<span class="op">;</span>
<span class="rem">// . . .</span>
<span class="op">}</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font><table
 width="640px"><tbody><tr><td style="text-align: justify;"><p>&nbsp;</p></td></tr></tbody></table>

<h4>Creation<a name="toc0020"></a></h4>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><a href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_markers">renderer_markers</a><span class="op">(</span>base_ren_type<span class="op">&amp;</span> rbuf<span class="op">)</span> :
    base_type<span class="op">(</span>rbuf<span class="op">)</span>
<span class="op">{</span><span class="op">}</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>As 
you can see, the creation is as simple as the <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a>
 one.</p></td></tr></tbody></table>

<h4>Member Functions<a name="toc0021"></a></h4>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>All 
the marker functions accept <code>x</code>, <code>y</code>, and <code>radius</code>
 in pixels.
The radius in the <code>pixel()</code> marker doesn't have any effect.
The fill and line colors are taken from the base class <a 
href="http://www.antigrain.com/doc/basic_renderers/basic_renderers.agdoc.html#renderer_primitives">renderer_primitives</a>.</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> square<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> diamond<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> circle<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> crossed_circle<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> semiellipse_left<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> semiellipse_right<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> semiellipse_up<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> semiellipse_down<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> triangle_left<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> triangle_right<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> triangle_up<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> triangle_down<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> four_rays<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> cross<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> xing<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> dash<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> dot<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">)</span><span class="op">;</span>
<span class="kw1">void</span> pixel<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span><span class="op">)</span><span class="op">;</span>
</pre></td></tr></tbody></table><font style="margin-left: 1em;"><i></i></font>

<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Also,
 there are some functions for the convenience that basically just use 
the <code>switch/case</code> construction:</p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">void</span> marker<span class="op">(</span><span class="kw1">int</span> x<span class="op">,</span> <span class="kw1">int</span> y<span class="op">,</span> <span class="kw1">int</span> r<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a> type<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a single marker of the given type.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> T<span class="op">&gt;</span>
<span class="kw1">void</span> markers<span class="op">(</span><span class="kw1">int</span> n<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> x<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> y<span class="op">,</span> T r<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a> type<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a number of markers of the given type and radius and coordinates 
stored in two arrays, <code>x</code> and <code>y</code>.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> T<span class="op">&gt;</span>
<span class="kw1">void</span> markers<span class="op">(</span><span class="kw1">int</span> n<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> x<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> y<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> r<span class="op">,</span> <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a> type<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a number of markers of the given type with coordinates and radii
stored in three arrays.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> T<span class="op">&gt;</span>
<span class="kw1">void</span> markers<span class="op">(</span><span class="kw1">int</span> n<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> x<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> y<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> r<span class="op">,</span> 
             <span class="kw1">const</span> color_type<span class="op">*</span> fill_colors<span class="op">,</span> 
             <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a> type<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a number of markers of the given type with coordinates and radii
stored in three arrays and of different fill colors.
<br><br></p></td></tr></tbody></table>

<table width="640px" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><pre><span class="kw1">template</span><span class="op">&lt;</span><span class="kw1">class</span> T<span class="op">&gt;</span>
<span class="kw1">void</span> markers<span class="op">(</span><span class="kw1">int</span> n<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> x<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> y<span class="op">,</span> <span class="kw1">const</span> T<span class="op">*</span> r<span class="op">,</span> 
             <span class="kw1">const</span> color_type<span class="op">*</span> fc<span class="op">,</span> <span class="kw1">const</span> color_type<span class="op">*</span> lc<span class="op">,</span> 
             <a href="http://www.antigrain.com/__code/include/agg_renderer_markers.h.html#marker_e">marker_e</a> type<span class="op">)</span><span class="op">;</span></pre></td></tr></tbody></table><font
 style="margin-left: 1em;"><i></i></font>
<table width="640px"><tbody><tr><td style="text-align: justify;"><p>Draw
 a number of markers of the given type with coordinates and radii
stored in three arrays and of different fill and line colors.
<br><br></p></td></tr></tbody></table>


<br><table style="margin: 0px;" height="1px" width="640px" 
bgcolor="#583927" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td></td></tr></tbody></table>
<table width="640px" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td><center><span class="authors">
Copyright <span class="larger"></span> 2002-2006
<a href="http://www.antigrain.com/mcseem/index.html"><b>Maxim Shemanarev</b></a>
</span></center></td></tr>
<tr><td><center><span class="authors">
Web Design and Programming
<a href="http://www.antigrain.com/mcseem/index.html"><b>Maxim Shemanarev</b></a>
</span></center></td></tr>
</tbody></table>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body></html>