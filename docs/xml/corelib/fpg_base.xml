<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>

<package name="fpGUI">
<descr><p>fpGUI Toolkit is intended for Open Source and Commercial applications.
fpGUI uses the LGPL2 license with the static linking exception - the same as
the Free Pascal Compiler's RTL.</p>
<p>fpGUI is an Object Pascal toolkit for cross-platform application development.
It provides single-source portability across Linux, MS Windows, *BSD, OpenSolaris and
embedded / mobile systems running Embedded Linux and Windows CE.</p>
<p>
For more information, see the fpGUI Toolkit website at: <url href="http://fpgui.sourceforge.net" />
</p>
</descr>

    <module name="fpg_base">
      <short>The base unit and starting point of fpGUI</short>
      <descr><p>This unit contains all the abstract classes for the CoreLib code
of fpGUI. It also defines many types and constants used throughout the toolkit.
</p>
        <p>When implementing support for a completely new windowing system 
(eg: Carbon used in Mac OS-X) you would implement all the abstract methods
defined in this unit.
</p>
      </descr>
      <!-- alias type Visibility: default -->
      <element name="TfpgCoord">
        <short>A custom type used to represent X and Y coordinates.</short>
        <descr>Internally TfpgCoord is actually a Integer type. We created a custom 
alias type for use in fpGUI in the event that we might want to change the 
underlying type in the future. Example to floating points.
</descr>
        <seealso/>
      </element>
      <!-- alias type Visibility: default -->
      <element name="TfpgColor">
        <short>Represents a color in integer format.</short>
        <descr>
          <p>TfpgColor is always in RRGGBB (Red, Green, Blue) format, no matter the
operating system.
</p>
          <p>The <var>fpg_base</var> unit also contains definitions of many useful color 
constants. It defines the standard predefined Delphi colors (like clRed, 
clMagenta etc.), the 140 web safe colors using the defacto standard names as 
used by Netscape and Internet Explorer web browsers. As well as some internal 
color constants used by many GUI components (like clText, clWindowBackground 
etc.).
</p>
        </descr>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TRGBTriple">
        <short>A record structure holding the RGBA values of a color</short>
        <descr><printshort id="TRGBTriple"/>. This is now marked as "deprecated". Please use <link id="fpg_base.TFPColor">TFPColor</link> instead.</descr>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TRGBTriple.Alpha">
        <short>Alpha support has not really been implemented in fpGUI yet.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWindowType">
        <short>Enum type defining what types of windows can be created.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWindowType.wtChild">
        <short>The window being created is a child on another window. This normally
means no titlebar or window borders are going to be created.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWindowType.wtWindow">
        <short>This would specify a standard window with titlebar and window borders.</short>
        <descr>This would specify a standard window with titlebar and window borders. It grabs input focus, and appears in the taskbar.</descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWindowType.wtModalForm">
        <short>This windows type is similar to wtWindow, but grabs focus.</short>
        <descr>This windows is the same as <link id="#fpgui.fpg_base.TWindowType.wtWindow">wtWindow</link>, but grabs the input focus until it has closed. This window normally doesn't appear in the taskbar.</descr>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TWindowType.wtPopup">
        <short>This window will normally not have a titlebar or window borders.</short>
        <descr>This window will normally not have a titlebar or window borders and will appear above other windows. It is used for example in the dropdown window of a ComboBox or a tooltip window or popup menus. This type of window does not steal focus.</descr>
      </element>

<element name="TWindowAttribute">
<short>An enum types defining extra attributes of a window.</short>
</element>

<element name="TWindowAttribute.waSizeable">
<short>If this attribute is set, the window will be resizeable by the user.</short>
</element>

<element name="TWindowAttribute.waAutoPos">
<short>If this attribute is set, the underlying window manager will decide where
the window will be placed on the screen, when it becomes visible for the first time.</short>
</element>

<element name="TWindowAttribute.waBorderless">
<short>The window will have no border painted. This is used in windows like Tooltips, Splash screens etc.</short>
</element>

<element name="TWindowAttribute.waFullScreen">
<short>When set, this will tell the window manager to create the window in a full screen state.</short>
</element>

<element name="TWindowAttribute.waOneThirdDownPos">
<short>When set, the fpGUI framework will calculate the remaining desktop space (minus the window height), and
then position the window one third of the way down (from the top of the screen). This is usually a more
desired position than the screen center.</short>
</element>

<element name="TWindowAttribute.waScreenCenterPos">
<short>If this attribute is set, the window will be centered on the screen when it is shown for
the first time.</short>
</element>

<element name="TWindowAttribute.waStayOnTop">
<short>If set, the window will always be above all other windows. This is used for example is Splash Screen windows.</short>
</element>

<element name="TWindowAttributes">
<short>A set of TWindowAttribute types.</short>
<seealso>
<link id="fpg_base.TWindowAttribute">TWindowAttribute</link>
</seealso>
</element>
      
      <!-- enumeration type Visibility: default -->
      <element name="TMouseCursor">
        <short>Enum types of the available mouse cursor shapes.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcDefault">
        <short>Normally the default arrow cursor.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcArrow">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcCross">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcIBeam">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeEW">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeNS">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeNWSE">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeNESW">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeSWNE">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcSizeSENW">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcMove">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TMouseCursor.mcHourGlass">
        <short>Normally a hourglass or watch representing a busy state.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TGradientDirection">
        <short>Enum types defining how a gradient must be painted</short>
        <descr/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TGradientDirection.gdVertical">
        <short>Defines that the gradient must be painted vertically.</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TGradientDirection.gdHorizontal">
        <short>Defines that the gradient must be painted horizontally.</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFileEntryType">
        <short>Represents the type of entry found on the filesystem.</short>
        <descr/>
        <seealso>
          <link id="TFileEntry"/>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFileEntryType.etFile">
        <short>Denotes a File type</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TFileEntryType.etDir">
        <short>Denotes a Directory type</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TClipboardKeyType">
        <short>Represents the clipboard function being triggered by some keyboard key combination.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TClipboardKeyType.ckNone">
        <short>No clipboard action detected</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TClipboardKeyType.ckCopy">
        <short>Copy to clipboard action detected</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TClipboardKeyType.ckPaste">
        <short>Paste to clipboard action detected</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TClipboardKeyType.ckCut">
        <short>Cut to clipboard action detected</short>
      </element>
      <!-- constant Visibility: default -->
      <element name="MOUSE_LEFT">
        <short>Constant representing the left mouse button.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="MOUSE_RIGHT">
        <short>Constant representing the right mouse button.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="MOUSE_MIDDLE">
        <short>Constant representing the middle mouse button.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_PAINT">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_ACTIVATE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_DEACTIVATE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_KEYPRESS">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_KEYRELEASE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_KEYCHAR">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOUSEDOWN">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOUSEUP">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOUSEMOVE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_DOUBLECLICK">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOUSEENTER">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOUSEEXIT">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_CLOSE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_SCROLL">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_RESIZE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_MOVE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_POPUPCLOSE">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPGM_KILLME">
        <short>Platform independent messages used by fpGUI.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- constant Visibility: default -->
      <element name="FPG_DEFAULT_FONT_DESC">
        <short>The default base font used in fpGUI</short>
        <descr/>
      </element>
      <!-- object Visibility: default -->
      <element name="TfpgRect">
        <short>A graphical (pixel based) rectangle structure used throughout fpGUI.</short>
        <descr>
          <p>Note that this structure is not a class, so static allocations are 
allowed. This makes it much easier to use in Widgets and in fpGUI internal
messages.</p>
          <p>Think of the pixel screen/grid like the grid of a spreadsheet (or as a magnified look of the top corner of your screen).
</p>
          <pre>.
     0   1
   +---+---+---
0  | x |   |
   +---+---+---
1  |   |   |
   +---+---+---
2  |   |   |
   +---+---+---
   |   |   |
</pre>
          <p>x is at (0,0). A pixel is always 1x1, you don't get smaller (we are not using sub-pixels like on LCD screens, because they don't apply to all screens).  
</p>
          <p>So with that example, Width = 1 pixel and Height = 1 pixel. In the case of 
Classes.Bounds() the Right and Bottom values are (1,1) which looking at the 
above image will be wrong, the pixel only covers one block, so in a screen/pixel 
environment, Right, Bottom is also (0,0), the same as Top/Left. This is what
TfpgRect.Right and TfpgRect.Bottom will report.
</p>
          <pre>.
     0   1
   +---+---+---
0  | x | x |
   +---+---+---
1  | x | x |
   +---+---+---
2  |   |   |
   +---+---+---
   |   |   |
</pre>
          <p>In this example we have a rectangle. Top/Left = (0,0) and Bottom/Right = (1,1). 
This means Width = 2 pixels and Height = 2 pixels. Clearly visible in the image 
above.
</p>
          <p>But if we call Classes.Bounds(0,0,2,2) it reports Bottom/Right as (2,2) which 
is wrong (again looking at the image above as reference). This is my point. 
Bounds() cannot be used in this case in a graphical environment.
</p>
          <p>The reason I don't use a grid layout as shown below, is 
because if the mouse is over the rectangle containing x, the OS (graphics system) reports its 
position as (0,0). You don't have to have the mouse pointer over the intersecting 
lines at (0,0) as indicated in the image below. The whole square containing 
the x is referenced as (0,0), hence the grid layout as show in the images above,
and what fpGUI uses. The same grid layout as used in TfpgStringGrid or any 
Spreadsheet program etc.
</p>
          <pre>.
   0   1   2
0  +---+---+---
   | x |   |
1  +---+---+---
   |   |   |
2  +---+---+---
   |   |   |
3  +---+---+---
   |   |   |
</pre>
        </descr>
        <errors/>
        <seealso/>
      </element>

      <!-- procedure Visibility: default -->
      <element name="TfpgRect.SetRect">
        <short>A convenience function to quickly set a rectangle structure.</short>
        <descr/>
      </element>

      <!-- function Visibility: default -->
      <element name="TfpgRect.Bottom">
        <short>Calculates and returns the bottom position of the rectangle.</short>
        <descr/>
      </element>

      <!-- function Visibility: default -->
      <element name="TfpgRect.Right">
        <short>Calculates and returns the Right most position of the rectangle.</short>
        <descr/>
      </element>

      <!-- procedure Visibility: default -->
      <element name="TfpgRect.SetBottom">
        <short>Sets the bottom value and recalculates the Height value.</short>
        <descr/>
      </element>

      <!-- procedure Visibility: default -->
      <element name="TfpgRect.SetRight">
        <short>Sets the Right value and recalculates the Width value.</short>
        <descr/>
      </element>

      <!-- record type Visibility: default -->
      <element name="TfpgMsgParmMouse">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmMouse.x">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmMouse.y">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmMouse.Buttons">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmMouse.shiftstate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmMouse.delta">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TfpgMsgParmKeyboard">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmKeyboard.keycode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmKeyboard.keychar">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMsgParmKeyboard.shiftstate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TfpgMessageParams">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageParams.mouse">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageParams.keyboard">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageParams.rect">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TfpgMessageRec">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageRec.MsgCode">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageRec.Sender">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageRec.Dest">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TfpgMessageRec.Params">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PfpgMessageRec">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TfpgLineStyle">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TfpgLineStyle.lsSolid">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TfpgLineStyle.lsDash">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TfpgLineStyle.lsDot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TfpgLineStyle.lsDashDot">
        <short/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TfpgLineStyle.lsDashDotDot">
        <short/>
      </element>
      <!-- object Visibility: default -->
      <element name="TfpgWindowBase">
        <short>Abstract class use for representing a Window or Widget</short>
        <descr>fpGUI is a <i>Windowed</i> toolkit. By that we mean that every
widget has a window handle. Widgets are essentially embedded windows without
titlebars or borders, inside a parent window.
</descr>
      </element>

<element name="TfpgWindowBase.UpdateWindowPosition">
<short>Forces fpGUI to act on window position and size properties</short>
<descr><p>fpGUI implements what is called "delayed resource allocation". It delays
some action until everything is ready to go. This delayed action applies to setting
Widget or Form size and position. Why? Imagine you have a complex form
with lots of anchors, alignments and OnResize event handlers. Now
somewhere in there you change the size or position of a component.</p>

<code>
MyWidget.Left := ...
MyWidget.Top := ...
MyWidget.Width := ...
MyWidget.Height := ...
</code>

<p>If fpGUI acted immediately, as every property is set, it means it
would have to recalculate all those widget boundaries, and fire all
OnResize event handlers of the whole form four times. Once for each
property - as you set them. Not very efficient! To reduce such
redundant calculations, fpGUI allows you to set all the properties,
then act on it once you call <var>UpdateWindowPosition</var>. In most cases fpGUI
can even reduce the API calls needed, because it could pass for
example Width and Height via one API call. In the case of X11, it can actually do all
four values in a single API call. Thus improving efficiency and reduces resize 
calculations and screen redraws.</p>
</descr>
</element>

<element name="TfpgWindowBase.Left">
<short>Specifies the horizontal coordinate of the left edge of a component relative to its parent</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgWindowBase.Left"/>. Use the Left property to determine where the left side
of the control begins or to reposition the left side of the control.
</p>
<remark>fpGUI delays acting on the Top, Left, Width and Height properties of a control until the
<var>UpdateWindowPosition</var> method is called. For more information on why this is so, 
see <link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">UpdateWindowPosition</link>
help.</remark></descr>
<seealso>
<link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">TfpgWindowBase.UpdateWindowPosition</link>
</seealso>
</element>

<element name="TfpgWindowBase.Top">
<short>Specifies the vertical (X) coordinate of the top edge of a component relative to its parent</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgWindowBase.Top"/>. Use the Top property to determine where the top side
of the control begins or to reposition the top side of the control.
</p>
<remark>fpGUI delays acting on the Top, Left, Width and Height properties of a control until the
<var>UpdateWindowPosition</var> method is called. For more information on why this 
is so, see <link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">UpdateWindowPosition</link>
help.</remark></descr>
<seealso>
<link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">TfpgWindowBase.UpdateWindowPosition</link>
</seealso>
</element>

<element name="TfpgWindowBase.Width">
<short>Specifies the horizontal size of the control or form in pixels</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgWindowBase.Width"/>. Use the Width property
to read or change the width of the control. For TfpgTabSheet controls of for
controls that have their Align property set to alTop, alBottom or alClient, changing
this property at runtime has no effect.
</p>
<remark>fpGUI delays acting on the Top, Left, Width and Height properties of a control until the
<var>UpdateWindowPosition</var> method is called. For more information on why this is so, 
see <link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">UpdateWindowPosition</link>
help.</remark></descr>
<seealso>
<link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">TfpgWindowBase.UpdateWindowPosition</link>
</seealso>
</element>

<element name="TfpgWindowBase.Height">
<short>Specifies the vertical size of the control or form in pixels</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgWindowBase.Height"/>. Use the Height property
to read or change the height of the control. For TfpgTabSheet controls of for
controls that have their Align property set to alLeft, alRight or alClient, changing
this property at runtime has no effect.
</p>
<remark>fpGUI delays acting on the Top, Left, Width and Height properties of a control until the
<var>UpdateWindowPosition</var> method is called. For more information on why this 
is so, see <link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">UpdateWindowPosition</link>
help.</remark></descr>
<seealso>
<link id="#fpgui.fpg_base.TfpgWindowBase.UpdateWindowPosition">TfpgWindowBase.UpdateWindowPosition</link>
</seealso>
</element>

<element name="TfpgWindowBase.BringToFront">
<short>Changes the z-order of a window</short>
<descr>This doesn't have much meaning at the widget level, but at the TfpgForm level,
it brings a window to the front - above all other windows of the application. Note that
this only changes the z-order, it doesn't actually change window focus.</descr>
<seealso>
<link id="fpg_base.TfpgWindowBase.ActivateWindow"></link>
</seealso>
</element>

<element name="TfpgWindowBase.ActivateWindow">
<short>This makse the target window the active window</short>
<descr>This doesn't have much meaning at the widget level, but at the TfpgForm level,
it makes the target window the active window. Note that depending on the operating system
and Window Manager, the active window could still be obscured by other windows. Under Windows,
it seems that the active window is always brought to the front too.</descr>
<seealso>
<link id="#fpgui.fpg_base.TfpgWindowBase.BringToFront"></link>
</seealso>
</element>

      <!-- object Visibility: default -->
      <element name="TfpgCanvasBase">
        <short>Abstract class used to represent a Canvas for painting</short>
        <descr/>
      </element>
      <!-- object Visibility: default -->
      <element name="TfpgImageBase">
        <short>Abstract class used to represent a Image</short>
        <descr/>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgImageBase.Invert">
        <short>Inverts the Image</short>
        <descr><printshort id="#fpgui.fpg_base.TfpgImageBase.Invert"/>. This changes the actual
data of the image. There is no undo function. So if you want to undo this action,
you must keep copy of the original image before you call <var>Invert</var>.</descr>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgImageBase.AllocateImage">
        <short>Allocates OS resources for the Image</short>
        <descr/>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgImageBase.AllocateMask">
        <short>Allocates OS resources for the Image Mask</short>
        <descr/>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgImageBase.CreateMaskFromSample">
        <short>Creates a mask based on the sample point presented by X and Y parameters</short>
        <descr/>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgImageBase.UpdateImage">
        <short>Updates the internal image resources and OS resources from image data</short>
        <descr/>
      </element>

      <!-- property Visibility: public -->
      <element name="TfpgImageBase.Width">
        <short>Width of the image</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TfpgImageBase.Height">
        <short>Height of the image</short>
        <descr/>
      </element>
      <!-- property Visibility: public -->
      <element name="TfpgImageBase.ColorDepth">
        <short>Color depth of the image. Currently 24/32-bit is all that is supported.</short>
        <descr/>
      </element>

      <!-- property Visibility: public -->
      <element name="TfpgImageBase.Colors">
        <short>Array property to access a specific color of the image based on X and Y co-ordinates</short>
        <descr/>
      </element>

      <!-- object Visibility: default -->
      <element name="TfpgFontResourceBase">
        <short>Encapsulates the resources of a font</short>
        <descr/>
      </element>

      <!-- object Visibility: default -->
      <element name="TfpgBaseInterpolation">
        <short>A abstract class representing a base Interpolation filter.</short>
        <descr>This is used as the base class to implement Interpolation filters like
Gaussian, Sinc etc... These decendant filters are used in the 
<link id="#fpgui.fpg_base.TfpgCanvasBase.StretchDraw">Canvas.StretchDraw</link> function.
</descr>
        <seealso>
          <link id="TfpgCanvasBase.StretchDraw">Canvas.StretchDraw</link>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TfpgCanvasBase.DrawRectangle">
        <short>Draws a rectangle.</short>
        <descr><printshort id="#fpgui.fpg_base.TfpgCanvasBase.DrawRectangle"/> You can specify the size of the rectangle via X, Y, Width and Height parameters or via a TfpgRect parameter.</descr>
      </element>

      <!-- procedure Visibility: public -->
      <element name="TfpgCanvasBase.DrawLine">
        <short>Draws a line</short>
        <descr><printshort id="#fpgui.fpg_base.TfpgCanvasBase.DrawLine"/>. This method 
draws a line from (x1,y1) to (x2,y2), but does not draw the last pixel. All supported 
backends follow the Microsoft API and doesn't draw the last pixel. This optimises 
consecutive lines being drawn without overlapping pixels.</descr>
      </element>

<element name="TfpgCanvasBase.StretchDraw">
<short>Allows you to draw a bitmap, stretched or shrunken from its original size</short>
<descr><printshort id="#fpgui.fpg_base.TfpgCanvasBase.StretchDraw"/>. Default
interpolation is <link id="#fpgui.fpg_base.TfpgMitchelInterpolation">TfpgMitchelInterpolation</link>,
but others (found in <link id="#fpgui.fpg_extinterpolation">fpg_extinterpolation.pas</link>) can
be used too, by using the <link id="#fpgui.fpg_base.TfpgCanvasBase.InterpolationFilter">InterpolationFilter</link> property of the Canvas.</descr>
</element>

      <!-- function Visibility: default -->
      <element name="KeycodeToText">
        <short>Returns the text representation of a keycode.</short>
        <descr>This is mainly used for debugging, but could also be used for Menu Item keyboard
shortcuts etc.
</descr>
      </element>

      <!-- function Visibility: default -->
      <element name="CheckClipboardKey">
        <short>Detects if the pressed keys represent a Clipboard key shortcut</short>
        <descr>Detects if the pressed keys represent a Clipboard key shortcut. If it does, it
returns the correct enum type detected.
</descr>
      </element>

      <!-- function Visibility: default -->
      <element name="fpgColorToRGBTriple">
        <short>Converts the TfpgColor to TRGBTriple type</short>
        <descr>This function converts the given TfpgColor into a TRGBTriple type.</descr>
        <seealso>
          <link id="#fpgui.fpg_base.TRGBTriple">TRGBTriple</link>
        </seealso>
      </element>

      <!-- function Visibility: default -->
      <element name="RGBTripleTofpgColor">
        <short>Converts the TRGBTriple to TfpgColor type</short>
        <descr>This function converts the given TRGBTriple into a TfpgColor type.
</descr>
        <seealso>
          <link id="#fpgui.fpg_base.TRGBTriple">TRGBTriple</link>
        </seealso>
      </element>
      <!-- function Visibility: default -->
      <element name="fpgGetRed">
        <short>Returns the Red portion of a color value.</short>
        <descr/>
      </element>

      <!-- function Visibility: default -->
      <element name="fpgGetGreen">
        <short>Returns the Green portion of a color value.</short>
        <descr/>
      </element>
      <!-- function Visibility: default -->
      <element name="fpgGetBlue">
        <short>Returns the Blue portion of a color value.</short>
        <descr/>
      </element>

      <!-- function Visibility: default -->
      <element name="fpgGetAlpha">
        <short>Returns the Alpha portion of a color value.</short>
        <descr/>
      </element>

      <!-- function Visibility: default -->
      <element name="fpgGetAvgColor">
        <short>Calculates the average color using the two supplied</short>
        <descr>This function calculates and returns the average color by using AColor1 
and AColor2. The Alpha value also gets taken into account.
</descr>
      </element>

      <!-- function Visibility: default -->
      <element name="PtInRect">
        <short>Returns true if APoint is inside ARect rectangle</short>
        <descr>This function is used to detect if the point APoint is inside the given
rectangle ARect.  If it is, the function returns True, otherwise False.
</descr>
      </element>

      <!-- procedure Visibility: default -->
      <element name="SortRect">
        <short>Fixes the Top, Bottom and Left, Right to always represent a valid rectangle</short>
        <descr>This function fixes a rectangle so that the Left point is always smaller than the 
Right. And the Top is always smaller than the Bottom.
</descr>
      </element>

      <element name="TfpgCanvasBase.DrawLineClipped">
        <short>Draws a line inside a clip rectangle</short>
        <descr><p><printshort id="#fpgui.fpg_base.TfpgCanvasBase.DrawLineClipped"/>. This procedure clips a line to the AClipRect boundaries and
 then calls the DrawLine procedure with the clipped coordinates.  If the line
 lies completely outside of the clip boundary, then the Line routine is not
 called.  This procedure uses the well known Cohen-Sutherland line clipping
 algorithm to clip each coordinate.</p>
<p>Use this if you do not want to change the Canvas.ClipRegion for some reason.
 For a detailed explanation see:  http://www.nondot.org/~sabre/graphpro/line6.html
</p></descr>
      </element>
      
      <element name="TfpgCanvasBase.ClipLine">
        <short>Clips the line based on AClipRect boundaries.</short>
        <descr>This does not do any drawing, in only clips the line coordinates. This method is used internally by <link id="TfpgCanvasBase.DrawLineClipped"/>.</descr>
      </element>


<element name="TfpgCanvasBase.GradientFill">
<short>Paints a rectangle with a gradient</short>
<descr><printshort id="#fpgui.fpg_base.TfpgCanvasBase.GradientFill"/>. If the gradient direction is
set to gdHorizontal, then it pains from left to right. If the gradient direction is
set to gdVertical, then it paints from top to bottom.</descr>
</element>


<element name="TfpgCanvasBase.DrawArc">
<short>Draws an outline arc shape</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgCanvasBase.DrawArc"/>. It uses the TfpgCanvas.Color
value to draw the arc.</p>
<dl>
<dt>x</dt>
<dd>The left x co-ordinate of the arc drawing position</dd>
<dt>y</dt>
<dd>The top y co-ordinate of the arc drawing position</dd>
<dt>w</dt>
<dd>The width of the whole arc</dd>
<dt>h</dt>
<dd>The height of the whole arc</dd>
<dt>a1</dt>
<dd>This is the starting point of the arc. A value of 0 is the 3 o'clock 
position. A value of 270 is the 6 o'clock position. Positive values move
counter-clockwise, and negative values move clockwise.</dd>
<dt>a2</dt>
<dd>This parameter is the length of the arc in degrees. A positive value
goes counter-clockwise, and a negative values goes clockwise.</dd>
</dl>
</descr>
<seealso>
  <link id="#fpgui.fpg_base.TfpgCanvasBase.FillArc">TfpgCanvasBase.FillArc</link>
</seealso>
<example file="examples/fpg_base.fpgcanvasbase.drawarc.pas"/>
</element>


<element name="TfpgCanvasBase.FillArc.a1">
<descr>This is the starting point of the arc. A value of 0 is the 3 o'clock 
position. A value of 270 is the 6 o'clock position. Positive values move
counter-clockwise, and negative values move clockwise.</descr>
</element>


<element name="TfpgCanvasBase.FillArc">
<short>Draws a filled arc shape</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgCanvasBase.FillArc"/>. It uses the TfpgCanvas.Color
value to draw and fill the arc.</p>
<dl>
<dt>x</dt>
<dd>The left x co-ordinate of the arc drawing position</dd>
<dt>y</dt>
<dd>The top y co-ordinate of the arc drawing position</dd>
<dt>w</dt>
<dd>The width of the whole arc</dd>
<dt>h</dt>
<dd>The height of the whole arc</dd>
<dt>a1</dt>
<dd>This is the starting point of the arc. A value of 0 is the 3 o'clock 
position. A value of 270 is the 6 o'clock position. Positive values move
counter-clockwise, and negative values move clockwise.</dd>
<dt>a2</dt>
<dd>This parameter is the length of the arc in degrees. A positive value
goes counter-clockwise, and a negative values goes clockwise.</dd>
</dl>
</descr>
<seealso>
  <link id="#fpgui.fpg_base.TfpgCanvasBase.DrawArc">TfpgCanvasBase.DrawArc</link>
</seealso>
<example file="examples/fpg_base.fpgcanvasbase.fillarc.pas"/>
</element>


      <element name="TFileEntry">
        <short>A simple data object representing a file</short>
        <descr><printshort id="TFileEntry"/>. Some properties are OS dependant.</descr>

      </element>
      <element name="TFileEntry.Name">
        <short>Name of a file</short>
      </element>

      <element name="TFileEntry.Extension">
        <short>The extension of a file</short>
      </element>

      <element name="TFileEntry.Size">
        <short>Size of a file in bytes</short>
      </element>

      <element name="TFileEntry.IsLink">
        <short>Is this item a symbolic link (on unix-type OSes)</short>
      </element>

      <element name="TFileEntry.LinkTarget">
        <short>If it is a symbolic link, LinkTarget is what it points too</short>
      </element>

      <element name="TFileEntry.ModTime">
        <short>Last modified timestamp</short>
      </element>

<element name="TFPColor">
<short>A record structure holding the RGBA values of a color.</short>
<descr>This is the same declaration as the one found in FPImage (included with the
Free Pascal Compiler). In future when FPImage is integrated with fpGUI, this declaration
will be removed.</descr>
</element>

<element name="TfpgPoint">
<short>An extension of the FPC TPoint structure</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgPoint"/>. This structure is used inside the fpGUI framework, and includes some extra methods like
calculating lengths between to points etc.</p></descr>
</element>

<element name="TfpgPoint.ManhattanLength">
<short>Quick calculation of the length between points</short>
<descr><p>Returns the sum of the absolute values of X and Y,
traditionally known as the "Manhattan length" of the vector from
the origin to the point. For example:</p>
<code>
var
  oldPosition: TfpgPoint;
  newPosition: TfpgPoint;
begin
  newPosition := MousePosition - oldPosition;
  if (newPosition.ManhattanLength > 5) then
  begin
    // the mouse has moved more than 5 pixels since the oldPosition
  end;
end;
</code>
<p>
Accuracy is traded for speed. This is a useful, and quick to calculate, approximation to the
true length:</p>
<code>
    TrueLength := sqrt(power(X, 2) + power(Y, 2));
</code>
<p>
The tradition of "Manhattan length" arises because such distances
apply to travelers who can only travel on a rectangular grid, like
the streets of Manhattan.</p>
<p>For a further explanation of "Manhattan length" see the Wikipedia article on
<url href="http://en.wikipedia.org/wiki/Taxicab_geometry">Taxicab geometry</url>.</p>
</descr>
</element>


<element name="TfpgComponent">
<short>A descendant of the FPC TComponent class</short>
<descr><p><printshort id="#fpgui.fpg_base.TfpgComponent"/>. It adds a location where we can extend
the TComponent, without having to make changes to each and every class in fpGUI.</p>
<p>For example: We added the TagPointer property (which is now largely obsolete) because
a while back the Tag property of TComponent could only store a 32bit value.
Many developers used it to store a pointer reference to a object under 32-bit system, but
this was not possible under 64-bit systems. After some time, FPC finally updated
the type of the Tag property to support 64-bit addresses too.</p></descr>
</element>

<element name="fpgComponent.HelpContext">
<short>A numeric ID for the widget's context-sensitive help topic</short>
<descr><p>HelpContext supports help systems that use numeric topic IDs. For help
systems that use topic keywords, see <link id="#fpgui.fpg_base.TfpgComponent.HelpKeyword">HelpKeyword</link>.</p>
<p>To enable context-sensitive help for a widget, set <link id="#fpgui.fpg_base.TfpgComponent.HelpType">HelpType</link> to htContext and
set HelpContext to a numeric topic ID. A topic ID of 0 (default) means that no help
topic is provided for the widget. A 0 ID also mean that the help system should
refer to the parent widget, if there is one, for a help topic; refer to the
<link id="#fpgui.fpg_widget.TfpgWidget.InvokeHelp">TfpgWidget.InvokeHelp</link> method
for more information.</p></descr>
</element>

<element name="TfpgApplicationBase">
<short>Base class for the fpgApplication variable</short>
<descr>This is the base class of TfpgApplication. All fpGUI-based applications
will contain a instance of TfpgApplication. It encapsulates the application as
a whole, and also supplies many useful functions and events.</descr>
</element>

<element name="TfpgApplicationBase.HelpFile">
<short>Specify a help file for the application</short>
<descr>This property is used to assign the help file (normally an INF file) which
contains the help for the application.</descr>
</element>

<element name="TfpgApplicationBase.InvokeHelp">
<short>Run the help viewer</short>
<descr>This method will invoke the defined help viewer, passing it the HelpContext
or HelpKeyword as parameter. The default help viewer is fpGUI's DocView.</descr>
</element>


<element name="TfpgBaseTimer.Enabled">
<short>Allows you to enable or disable the timer</short>
<descr><printshort id="#fpgui.fpg_base.TfpgBaseTimer.Enabled"/>. The timer will not function until you
set the Enabled property to True. Later you can disable the timer by setting the
Enabled property to False.</descr>
</element>


    </module>
    <!-- fpg_base -->
  </package>
</fpdoc-descriptions>
